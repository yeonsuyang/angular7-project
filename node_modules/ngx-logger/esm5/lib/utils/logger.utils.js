/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { NgxLoggerLevel } from '../types/logger-level.enum';
var NGXLoggerUtils = /** @class */ (function () {
    function NGXLoggerUtils() {
    }
    /**
     * @param {?} timestamp
     * @param {?} logLevel
     * @param {?} fileName
     * @param {?} lineNumber
     * @return {?}
     */
    NGXLoggerUtils.prepareMetaString = /**
     * @param {?} timestamp
     * @param {?} logLevel
     * @param {?} fileName
     * @param {?} lineNumber
     * @return {?}
     */
    function (timestamp, logLevel, fileName, lineNumber) {
        /** @type {?} */
        var fileDetails = fileName ? " [" + fileName + ":" + lineNumber + "]" : '';
        return timestamp + " " + logLevel + fileDetails;
    };
    /**
     * @param {?} level
     * @return {?}
     */
    NGXLoggerUtils.getColor = /**
     * @param {?} level
     * @return {?}
     */
    function (level) {
        switch (level) {
            case NgxLoggerLevel.TRACE:
                return 'blue';
            case NgxLoggerLevel.DEBUG:
                return 'teal';
            case NgxLoggerLevel.INFO:
            case NgxLoggerLevel.LOG:
                return 'gray';
            case NgxLoggerLevel.WARN:
            case NgxLoggerLevel.ERROR:
            case NgxLoggerLevel.FATAL:
                return 'red';
            case NgxLoggerLevel.OFF:
            default:
                return;
        }
    };
    /**
     *  This allows us to see who called the logger
     */
    /**
     *  This allows us to see who called the logger
     * @return {?}
     */
    NGXLoggerUtils.getCallerDetails = /**
     *  This allows us to see who called the logger
     * @return {?}
     */
    function () {
        /** @type {?} */
        var err = (new Error(''));
        try {
            // this should produce the line which NGX Logger was called
            /** @type {?} */
            var callerLine = err.stack.split('\n')[4].split('/');
            // returns the file:lineNumber
            /** @type {?} */
            var fileLineNumber = callerLine[callerLine.length - 1].replace(/[)]/g, '').split(':');
            return {
                fileName: fileLineNumber[0],
                lineNumber: fileLineNumber[1]
            };
        }
        catch (e) {
            return {
                fileName: null,
                lineNumber: null
            };
        }
    };
    /**
     * @param {?} message
     * @return {?}
     */
    NGXLoggerUtils.prepareMessage = /**
     * @param {?} message
     * @return {?}
     */
    function (message) {
        try {
            if (typeof message !== 'string' && !(message instanceof Error)) {
                message = JSON.stringify(message, null, 2);
            }
        }
        catch (e) {
            // additional = [message, ...additional];
            message = 'The provided "message" value could not be parsed with JSON.stringify().';
        }
        return message;
    };
    /**
     * @param {?} additional
     * @return {?}
     */
    NGXLoggerUtils.prepareAdditionalParameters = /**
     * @param {?} additional
     * @return {?}
     */
    function (additional) {
        if (additional === null || additional === undefined) {
            return null;
        }
        return additional.map((/**
         * @param {?} next
         * @param {?} idx
         * @return {?}
         */
        function (next, idx) {
            try {
                // We just want to make sure the JSON can be parsed, we do not want to actually change the type
                if (typeof next === 'object') {
                    JSON.stringify(next);
                }
                return next;
            }
            catch (e) {
                return "The additional[" + idx + "] value could not be parsed using JSON.stringify().";
            }
        }));
    };
    return NGXLoggerUtils;
}());
export { NGXLoggerUtils };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibG9nZ2VyLnV0aWxzLmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmd4LWxvZ2dlci8iLCJzb3VyY2VzIjpbImxpYi91dGlscy9sb2dnZXIudXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBQyxjQUFjLEVBQUMsTUFBTSw0QkFBNEIsQ0FBQztBQUUxRDtJQUFBO0lBc0ZBLENBQUM7Ozs7Ozs7O0lBcEZRLGdDQUFpQjs7Ozs7OztJQUF4QixVQUF5QixTQUFpQixFQUFFLFFBQWdCLEVBQUUsUUFBZ0IsRUFBRSxVQUFrQjs7WUFDMUYsV0FBVyxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsT0FBSyxRQUFRLFNBQUksVUFBVSxNQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUU7UUFFbEUsT0FBVSxTQUFTLFNBQUksUUFBUSxHQUFHLFdBQWEsQ0FBQztJQUNsRCxDQUFDOzs7OztJQUVNLHVCQUFROzs7O0lBQWYsVUFBZ0IsS0FBcUI7UUFDbkMsUUFBUSxLQUFLLEVBQUU7WUFDYixLQUFLLGNBQWMsQ0FBQyxLQUFLO2dCQUN2QixPQUFPLE1BQU0sQ0FBQztZQUNoQixLQUFLLGNBQWMsQ0FBQyxLQUFLO2dCQUN2QixPQUFPLE1BQU0sQ0FBQztZQUNoQixLQUFLLGNBQWMsQ0FBQyxJQUFJLENBQUM7WUFDekIsS0FBSyxjQUFjLENBQUMsR0FBRztnQkFDckIsT0FBTyxNQUFNLENBQUM7WUFDaEIsS0FBSyxjQUFjLENBQUMsSUFBSSxDQUFDO1lBQ3pCLEtBQUssY0FBYyxDQUFDLEtBQUssQ0FBQztZQUMxQixLQUFLLGNBQWMsQ0FBQyxLQUFLO2dCQUN2QixPQUFPLEtBQUssQ0FBQztZQUNmLEtBQUssY0FBYyxDQUFDLEdBQUcsQ0FBQztZQUN4QjtnQkFDRSxPQUFPO1NBQ1Y7SUFDSCxDQUFDO0lBR0Q7O09BRUc7Ozs7O0lBQ0ksK0JBQWdCOzs7O0lBQXZCOztZQUNRLEdBQUcsR0FBRyxDQUFDLElBQUksS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBRTNCLElBQUk7OztnQkFFSSxVQUFVLEdBQUcsR0FBRyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQzs7O2dCQUdoRCxjQUFjLEdBQUcsVUFBVSxDQUFDLFVBQVUsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDO1lBRXZGLE9BQU87Z0JBQ0wsUUFBUSxFQUFFLGNBQWMsQ0FBQyxDQUFDLENBQUM7Z0JBQzNCLFVBQVUsRUFBRSxjQUFjLENBQUMsQ0FBQyxDQUFDO2FBQzlCLENBQUM7U0FDSDtRQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ1YsT0FBTztnQkFDTCxRQUFRLEVBQUUsSUFBSTtnQkFDZCxVQUFVLEVBQUUsSUFBSTthQUNqQixDQUFDO1NBQ0g7SUFFSCxDQUFDOzs7OztJQUVNLDZCQUFjOzs7O0lBQXJCLFVBQXNCLE9BQU87UUFDM0IsSUFBSTtZQUNGLElBQUksT0FBTyxPQUFPLEtBQUssUUFBUSxJQUFJLENBQUMsQ0FBQyxPQUFPLFlBQVksS0FBSyxDQUFDLEVBQUU7Z0JBQzlELE9BQU8sR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUM7YUFDNUM7U0FDRjtRQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ1YseUNBQXlDO1lBQ3pDLE9BQU8sR0FBRyx5RUFBeUUsQ0FBQztTQUNyRjtRQUVELE9BQU8sT0FBTyxDQUFDO0lBQ2pCLENBQUM7Ozs7O0lBRU0sMENBQTJCOzs7O0lBQWxDLFVBQW1DLFVBQWlCO1FBQ2xELElBQUksVUFBVSxLQUFLLElBQUksSUFBSSxVQUFVLEtBQUssU0FBUyxFQUFFO1lBQ25ELE9BQU8sSUFBSSxDQUFDO1NBQ2I7UUFFRCxPQUFPLFVBQVUsQ0FBQyxHQUFHOzs7OztRQUFDLFVBQUMsSUFBSSxFQUFFLEdBQUc7WUFDOUIsSUFBSTtnQkFDRiwrRkFBK0Y7Z0JBQy9GLElBQUksT0FBTyxJQUFJLEtBQUssUUFBUSxFQUFFO29CQUM1QixJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDO2lCQUN0QjtnQkFFRCxPQUFPLElBQUksQ0FBQzthQUNiO1lBQUMsT0FBTyxDQUFDLEVBQUU7Z0JBQ1YsT0FBTyxvQkFBa0IsR0FBRyx3REFBcUQsQ0FBQzthQUNuRjtRQUNILENBQUMsRUFBQyxDQUFDO0lBQ0wsQ0FBQztJQUVILHFCQUFDO0FBQUQsQ0FBQyxBQXRGRCxJQXNGQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7Tmd4TG9nZ2VyTGV2ZWx9IGZyb20gJy4uL3R5cGVzL2xvZ2dlci1sZXZlbC5lbnVtJztcblxuZXhwb3J0IGNsYXNzIE5HWExvZ2dlclV0aWxzIHtcblxuICBzdGF0aWMgcHJlcGFyZU1ldGFTdHJpbmcodGltZXN0YW1wOiBzdHJpbmcsIGxvZ0xldmVsOiBzdHJpbmcsIGZpbGVOYW1lOiBzdHJpbmcsIGxpbmVOdW1iZXI6IHN0cmluZykge1xuICAgIGNvbnN0IGZpbGVEZXRhaWxzID0gZmlsZU5hbWUgPyBgIFske2ZpbGVOYW1lfToke2xpbmVOdW1iZXJ9XWAgOiAnJztcblxuICAgIHJldHVybiBgJHt0aW1lc3RhbXB9ICR7bG9nTGV2ZWx9JHtmaWxlRGV0YWlsc31gO1xuICB9XG5cbiAgc3RhdGljIGdldENvbG9yKGxldmVsOiBOZ3hMb2dnZXJMZXZlbCk6ICdibHVlJyB8ICd0ZWFsJyB8ICdncmF5JyB8ICdyZWQnIHwgdW5kZWZpbmVkIHtcbiAgICBzd2l0Y2ggKGxldmVsKSB7XG4gICAgICBjYXNlIE5neExvZ2dlckxldmVsLlRSQUNFOlxuICAgICAgICByZXR1cm4gJ2JsdWUnO1xuICAgICAgY2FzZSBOZ3hMb2dnZXJMZXZlbC5ERUJVRzpcbiAgICAgICAgcmV0dXJuICd0ZWFsJztcbiAgICAgIGNhc2UgTmd4TG9nZ2VyTGV2ZWwuSU5GTzpcbiAgICAgIGNhc2UgTmd4TG9nZ2VyTGV2ZWwuTE9HOlxuICAgICAgICByZXR1cm4gJ2dyYXknO1xuICAgICAgY2FzZSBOZ3hMb2dnZXJMZXZlbC5XQVJOOlxuICAgICAgY2FzZSBOZ3hMb2dnZXJMZXZlbC5FUlJPUjpcbiAgICAgIGNhc2UgTmd4TG9nZ2VyTGV2ZWwuRkFUQUw6XG4gICAgICAgIHJldHVybiAncmVkJztcbiAgICAgIGNhc2UgTmd4TG9nZ2VyTGV2ZWwuT0ZGOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG5cbiAgLyoqXG4gICAqICBUaGlzIGFsbG93cyB1cyB0byBzZWUgd2hvIGNhbGxlZCB0aGUgbG9nZ2VyXG4gICAqL1xuICBzdGF0aWMgZ2V0Q2FsbGVyRGV0YWlscygpOiB7IGxpbmVOdW1iZXI6IHN0cmluZywgZmlsZU5hbWU6IHN0cmluZyB9IHtcbiAgICBjb25zdCBlcnIgPSAobmV3IEVycm9yKCcnKSk7XG5cbiAgICB0cnkge1xuICAgICAgLy8gdGhpcyBzaG91bGQgcHJvZHVjZSB0aGUgbGluZSB3aGljaCBOR1ggTG9nZ2VyIHdhcyBjYWxsZWRcbiAgICAgIGNvbnN0IGNhbGxlckxpbmUgPSBlcnIuc3RhY2suc3BsaXQoJ1xcbicpWzRdLnNwbGl0KCcvJyk7XG5cbiAgICAgIC8vIHJldHVybnMgdGhlIGZpbGU6bGluZU51bWJlclxuICAgICAgY29uc3QgZmlsZUxpbmVOdW1iZXIgPSBjYWxsZXJMaW5lW2NhbGxlckxpbmUubGVuZ3RoIC0gMV0ucmVwbGFjZSgvWyldL2csICcnKS5zcGxpdCgnOicpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBmaWxlTmFtZTogZmlsZUxpbmVOdW1iZXJbMF0sXG4gICAgICAgIGxpbmVOdW1iZXI6IGZpbGVMaW5lTnVtYmVyWzFdXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGZpbGVOYW1lOiBudWxsLFxuICAgICAgICBsaW5lTnVtYmVyOiBudWxsXG4gICAgICB9O1xuICAgIH1cblxuICB9XG5cbiAgc3RhdGljIHByZXBhcmVNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSAnc3RyaW5nJyAmJiAhKG1lc3NhZ2UgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgbWVzc2FnZSA9IEpTT04uc3RyaW5naWZ5KG1lc3NhZ2UsIG51bGwsIDIpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIGFkZGl0aW9uYWwgPSBbbWVzc2FnZSwgLi4uYWRkaXRpb25hbF07XG4gICAgICBtZXNzYWdlID0gJ1RoZSBwcm92aWRlZCBcIm1lc3NhZ2VcIiB2YWx1ZSBjb3VsZCBub3QgYmUgcGFyc2VkIHdpdGggSlNPTi5zdHJpbmdpZnkoKS4nO1xuICAgIH1cblxuICAgIHJldHVybiBtZXNzYWdlO1xuICB9XG5cbiAgc3RhdGljIHByZXBhcmVBZGRpdGlvbmFsUGFyYW1ldGVycyhhZGRpdGlvbmFsOiBhbnlbXSkge1xuICAgIGlmIChhZGRpdGlvbmFsID09PSBudWxsIHx8IGFkZGl0aW9uYWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFkZGl0aW9uYWwubWFwKChuZXh0LCBpZHgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFdlIGp1c3Qgd2FudCB0byBtYWtlIHN1cmUgdGhlIEpTT04gY2FuIGJlIHBhcnNlZCwgd2UgZG8gbm90IHdhbnQgdG8gYWN0dWFsbHkgY2hhbmdlIHRoZSB0eXBlXG4gICAgICAgIGlmICh0eXBlb2YgbmV4dCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBKU09OLnN0cmluZ2lmeShuZXh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gYFRoZSBhZGRpdGlvbmFsWyR7aWR4fV0gdmFsdWUgY291bGQgbm90IGJlIHBhcnNlZCB1c2luZyBKU09OLnN0cmluZ2lmeSgpLmA7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxufVxuIl19