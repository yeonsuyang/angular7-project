/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Injectable } from '@angular/core';
import { HttpBackend, HttpRequest, HttpResponse } from '@angular/common/http';
import * as vlq from 'vlq';
import { of } from 'rxjs';
import { catchError, filter, map, retry, switchMap } from 'rxjs/operators';
import { LogPosition } from './types/log-position';
var NGXMapperService = /** @class */ (function () {
    function NGXMapperService(httpBackend) {
        this.httpBackend = httpBackend;
        // used to cache source maps
        this.cache = {};
        this.errorCache = {};
    }
    /*
    Static Functions
   */
    /*
      Static Functions
     */
    /**
     * @private
     * @return {?}
     */
    NGXMapperService.getStackLine = /*
      Static Functions
     */
    /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var error = new Error();
        try {
            // noinspection ExceptionCaughtLocallyJS
            throw error;
        }
        catch (e) {
            try {
                return error.stack.split('\n')[5];
            }
            catch (e) {
                return null;
            }
        }
    };
    /**
     * @private
     * @param {?} stackLine
     * @return {?}
     */
    NGXMapperService.getPosition = /**
     * @private
     * @param {?} stackLine
     * @return {?}
     */
    function (stackLine) {
        // strip base path, then parse filename, line, and column
        /** @type {?} */
        var position = stackLine.substring(stackLine.lastIndexOf('\/') + 1, stackLine.indexOf(')'));
        /** @type {?} */
        var dataArray = position.split(':');
        if (dataArray.length === 3) {
            return new LogPosition(dataArray[0], +dataArray[1], +dataArray[2]);
        }
        return new LogPosition('unknown', 0, 0);
    };
    /**
     * @private
     * @param {?} stackLine
     * @return {?}
     */
    NGXMapperService.getTranspileLocation = /**
     * @private
     * @param {?} stackLine
     * @return {?}
     */
    function (stackLine) {
        return stackLine.substring(stackLine.indexOf('(') + 1, stackLine.indexOf(')'));
    };
    /**
     * @private
     * @param {?} stackLine
     * @return {?}
     */
    NGXMapperService.getMapFilePath = /**
     * @private
     * @param {?} stackLine
     * @return {?}
     */
    function (stackLine) {
        /** @type {?} */
        var file = NGXMapperService.getTranspileLocation(stackLine);
        /** @type {?} */
        var mapFullPath = file.substring(0, file.lastIndexOf(':'));
        return mapFullPath.substring(0, mapFullPath.lastIndexOf(':')) + '.map';
    };
    /**
     * @private
     * @param {?} sourceMap
     * @param {?} position
     * @return {?}
     */
    NGXMapperService.getMapping = /**
     * @private
     * @param {?} sourceMap
     * @param {?} position
     * @return {?}
     */
    function (sourceMap, position) {
        // => ';' indicates end of a line
        // => ',' separates mappings in a line
        // decoded mapping => [ generatedCodeColumn, sourceFileIndex, sourceCodeLine, sourceCodeColumn, nameIndex ]
        /** @type {?} */
        var sourceFileIndex = 0;
        /** @type {?} */
        var // second field
        sourceCodeLine = 0;
        /** @type {?} */
        var // third field
        sourceCodeColumn = 0;
        // fourth field
        /** @type {?} */
        var lines = sourceMap.mappings.split(';');
        for (var lineIndex = 0; lineIndex < lines.length; lineIndex++) {
            // reset column position to 0 after each line
            /** @type {?} */
            var generatedCodeColumn = 0;
            // decode sections in line
            /** @type {?} */
            var columns = lines[lineIndex].split(',');
            for (var columnIndex = 0; columnIndex < columns.length; columnIndex++) {
                /** @type {?} */
                var decodedSection = vlq.decode(columns[columnIndex]);
                if (decodedSection.length >= 4) {
                    // update relative positions
                    generatedCodeColumn += decodedSection[0];
                    sourceFileIndex += decodedSection[1];
                    sourceCodeLine += decodedSection[2];
                    sourceCodeColumn += decodedSection[3];
                }
                // check if matching map
                if (lineIndex === position.lineNumber) {
                    if (generatedCodeColumn === position.columnNumber) {
                        // matching column and line found
                        return new LogPosition(sourceMap.sources[sourceFileIndex], sourceCodeLine, sourceCodeColumn);
                    }
                    else if (columnIndex + 1 === columns.length) {
                        // matching column not found, but line is correct
                        return new LogPosition(sourceMap.sources[sourceFileIndex], sourceCodeLine, 0);
                    }
                }
            }
        }
        // failed if reached
        return new LogPosition('unknown', 0, 0);
    };
    /**
     * does the http get request to get the source map
     * @param sourceMapLocation
     * @param distPosition
     */
    /**
     * does the http get request to get the source map
     * @private
     * @param {?} sourceMapLocation
     * @param {?} distPosition
     * @return {?}
     */
    NGXMapperService.prototype._getSourceMap = /**
     * does the http get request to get the source map
     * @private
     * @param {?} sourceMapLocation
     * @param {?} distPosition
     * @return {?}
     */
    function (sourceMapLocation, distPosition) {
        var _this = this;
        /** @type {?} */
        var req = new HttpRequest('GET', sourceMapLocation);
        return this.httpBackend.handle(req).pipe(filter((/**
         * @param {?} e
         * @return {?}
         */
        function (e) { return (e instanceof HttpResponse); })), map((/**
         * @param {?} httpResponse
         * @return {?}
         */
        function (httpResponse) { return httpResponse.body; })), map((/**
         * @param {?} sourceMap
         * @return {?}
         */
        function (sourceMap) {
            // store file in cache if not already stored
            if (!_this.cache.hasOwnProperty(sourceMapLocation)) {
                _this.cache[sourceMapLocation] = sourceMap;
            }
            // map generated position to source position
            return NGXMapperService.getMapping(sourceMap, distPosition);
        })), retry(3), 
        // if there is an error getting the source, map fall back to the filename and line number of
        catchError((/**
         * @return {?}
         */
        function () {
            _this.errorCache[sourceMapLocation] = true;
            return of(distPosition);
        })));
    };
    /**
     * Returns the LogPosition for the current log
     * If sourceMaps are enabled, it attemps to get the source map from the server, and use that to parse the file name
     * and number of the call
     * @param sourceMapsEnabled
     */
    /**
     * Returns the LogPosition for the current log
     * If sourceMaps are enabled, it attemps to get the source map from the server, and use that to parse the file name
     * and number of the call
     * @param {?} sourceMapsEnabled
     * @return {?}
     */
    NGXMapperService.prototype.getCallerDetails = /**
     * Returns the LogPosition for the current log
     * If sourceMaps are enabled, it attemps to get the source map from the server, and use that to parse the file name
     * and number of the call
     * @param {?} sourceMapsEnabled
     * @return {?}
     */
    function (sourceMapsEnabled) {
        // parse generated file mapping from stack trace
        var _this = this;
        // parse generated file mapping from stack trace
        /** @type {?} */
        var stackLine = NGXMapperService.getStackLine();
        // if we were not able to parse the stackLine, just return an empty Log Position
        if (!stackLine) {
            return of(new LogPosition('', 0, 0));
        }
        return of([
            NGXMapperService.getPosition(stackLine),
            NGXMapperService.getMapFilePath(stackLine)
        ]).pipe(switchMap((/**
         * @param {?} __0
         * @return {?}
         */
        function (_a) {
            var _b = tslib_1.__read(_a, 2), distPosition = _b[0], sourceMapLocation = _b[1];
            // if source maps are not enabled, or if we've previously tried to get the source maps, but they failed,
            // then just use the position of the JS instead of the source
            if (!sourceMapsEnabled || _this.errorCache.hasOwnProperty(sourceMapLocation)) {
                return of(distPosition);
            }
            // check if we have map has already, otherwise request from server
            if (_this.cache.hasOwnProperty(sourceMapLocation)) {
                return of(NGXMapperService.getMapping(_this.cache[sourceMapLocation], distPosition));
            }
            // finally try to get the source map and return the position
            return _this._getSourceMap(sourceMapLocation, distPosition);
        })));
    };
    NGXMapperService.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    NGXMapperService.ctorParameters = function () { return [
        { type: HttpBackend }
    ]; };
    return NGXMapperService;
}());
export { NGXMapperService };
if (false) {
    /**
     * @type {?}
     * @private
     */
    NGXMapperService.prototype.cache;
    /**
     * @type {?}
     * @private
     */
    NGXMapperService.prototype.errorCache;
    /**
     * @type {?}
     * @private
     */
    NGXMapperService.prototype.httpBackend;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFwcGVyLnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9uZ3gtbG9nZ2VyLyIsInNvdXJjZXMiOlsibGliL21hcHBlci5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQ0EsT0FBTyxFQUFDLFVBQVUsRUFBQyxNQUFNLGVBQWUsQ0FBQztBQUN6QyxPQUFPLEVBQUMsV0FBVyxFQUFFLFdBQVcsRUFBRSxZQUFZLEVBQUMsTUFBTSxzQkFBc0IsQ0FBQztBQUM1RSxPQUFPLEtBQUssR0FBRyxNQUFNLEtBQUssQ0FBQztBQUMzQixPQUFPLEVBQWEsRUFBRSxFQUFDLE1BQU0sTUFBTSxDQUFDO0FBQ3BDLE9BQU8sRUFBQyxVQUFVLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxLQUFLLEVBQUUsU0FBUyxFQUFDLE1BQU0sZ0JBQWdCLENBQUM7QUFDekUsT0FBTyxFQUFDLFdBQVcsRUFBQyxNQUFNLHNCQUFzQixDQUFDO0FBRWpEO0lBT0UsMEJBQW9CLFdBQXdCO1FBQXhCLGdCQUFXLEdBQVgsV0FBVyxDQUFhOztRQUhwQyxVQUFLLEdBQWlDLEVBQUUsQ0FBQztRQUN6QyxlQUFVLEdBQStCLEVBQUUsQ0FBQztJQUdwRCxDQUFDO0lBRUQ7O0tBRUM7Ozs7Ozs7O0lBQ2MsNkJBQVk7Ozs7Ozs7SUFBM0I7O1lBQ1EsS0FBSyxHQUFHLElBQUksS0FBSyxFQUFFO1FBRXpCLElBQUk7WUFDRix3Q0FBd0M7WUFDeEMsTUFBTSxLQUFLLENBQUM7U0FDYjtRQUFDLE9BQU8sQ0FBQyxFQUFFO1lBRVYsSUFBSTtnQkFDRixPQUFPLEtBQUssQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2FBQ25DO1lBQUMsT0FBTyxDQUFDLEVBQUU7Z0JBQ1YsT0FBTyxJQUFJLENBQUM7YUFDYjtTQUNGO0lBQ0gsQ0FBQzs7Ozs7O0lBRWMsNEJBQVc7Ozs7O0lBQTFCLFVBQTJCLFNBQWlCOzs7WUFFcEMsUUFBUSxHQUFHLFNBQVMsQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsU0FBUyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQzs7WUFDdkYsU0FBUyxHQUFHLFFBQVEsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDO1FBQ3JDLElBQUksU0FBUyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7WUFDMUIsT0FBTyxJQUFJLFdBQVcsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUNwRTtRQUNELE9BQU8sSUFBSSxXQUFXLENBQUMsU0FBUyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUMxQyxDQUFDOzs7Ozs7SUFFYyxxQ0FBb0I7Ozs7O0lBQW5DLFVBQW9DLFNBQWlCO1FBQ25ELE9BQU8sU0FBUyxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsRUFBRSxTQUFTLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDakYsQ0FBQzs7Ozs7O0lBRWMsK0JBQWM7Ozs7O0lBQTdCLFVBQThCLFNBQWlCOztZQUN2QyxJQUFJLEdBQUcsZ0JBQWdCLENBQUMsb0JBQW9CLENBQUMsU0FBUyxDQUFDOztZQUN2RCxXQUFXLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUM1RCxPQUFPLFdBQVcsQ0FBQyxTQUFTLENBQUMsQ0FBQyxFQUFFLFdBQVcsQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUM7SUFDekUsQ0FBQzs7Ozs7OztJQUVjLDJCQUFVOzs7Ozs7SUFBekIsVUFBMEIsU0FBb0IsRUFBRSxRQUFxQjs7Ozs7WUFJL0QsZUFBZSxHQUFHLENBQUM7O1lBQUksZUFBZTtRQUN4QyxjQUFjLEdBQUcsQ0FBQzs7WUFBSyxjQUFjO1FBQ3JDLGdCQUFnQixHQUFHLENBQUM7OztZQUVoQixLQUFLLEdBQUcsU0FBUyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDO1FBRTNDLEtBQUssSUFBSSxTQUFTLEdBQUcsQ0FBQyxFQUFFLFNBQVMsR0FBRyxLQUFLLENBQUMsTUFBTSxFQUFFLFNBQVMsRUFBRSxFQUFFOzs7Z0JBRXpELG1CQUFtQixHQUFHLENBQUM7OztnQkFFckIsT0FBTyxHQUFHLEtBQUssQ0FBQyxTQUFTLENBQUMsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDO1lBRTNDLEtBQUssSUFBSSxXQUFXLEdBQUcsQ0FBQyxFQUFFLFdBQVcsR0FBRyxPQUFPLENBQUMsTUFBTSxFQUFFLFdBQVcsRUFBRSxFQUFFOztvQkFDL0QsY0FBYyxHQUFHLEdBQUcsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQyxDQUFDO2dCQUN2RCxJQUFJLGNBQWMsQ0FBQyxNQUFNLElBQUksQ0FBQyxFQUFFO29CQUM5Qiw0QkFBNEI7b0JBQzVCLG1CQUFtQixJQUFJLGNBQWMsQ0FBQyxDQUFDLENBQUMsQ0FBQztvQkFDekMsZUFBZSxJQUFJLGNBQWMsQ0FBQyxDQUFDLENBQUMsQ0FBQztvQkFDckMsY0FBYyxJQUFJLGNBQWMsQ0FBQyxDQUFDLENBQUMsQ0FBQztvQkFDcEMsZ0JBQWdCLElBQUksY0FBYyxDQUFDLENBQUMsQ0FBQyxDQUFDO2lCQUN2QztnQkFFRCx3QkFBd0I7Z0JBQ3hCLElBQUksU0FBUyxLQUFLLFFBQVEsQ0FBQyxVQUFVLEVBQUU7b0JBQ3JDLElBQUksbUJBQW1CLEtBQUssUUFBUSxDQUFDLFlBQVksRUFBRTt3QkFDakQsaUNBQWlDO3dCQUNqQyxPQUFPLElBQUksV0FBVyxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsZUFBZSxDQUFDLEVBQUUsY0FBYyxFQUFFLGdCQUFnQixDQUFDLENBQUM7cUJBQzlGO3lCQUFNLElBQUksV0FBVyxHQUFHLENBQUMsS0FBSyxPQUFPLENBQUMsTUFBTSxFQUFFO3dCQUM3QyxpREFBaUQ7d0JBQ2pELE9BQU8sSUFBSSxXQUFXLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxlQUFlLENBQUMsRUFBRSxjQUFjLEVBQUUsQ0FBQyxDQUFDLENBQUM7cUJBQy9FO2lCQUNGO2FBQ0Y7U0FDRjtRQUNELG9CQUFvQjtRQUNwQixPQUFPLElBQUksV0FBVyxDQUFDLFNBQVMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDMUMsQ0FBQztJQUVEOzs7O09BSUc7Ozs7Ozs7O0lBQ0ssd0NBQWE7Ozs7Ozs7SUFBckIsVUFBc0IsaUJBQXlCLEVBQUUsWUFBeUI7UUFBMUUsaUJBcUJDOztZQXBCTyxHQUFHLEdBQUcsSUFBSSxXQUFXLENBQVksS0FBSyxFQUFFLGlCQUFpQixDQUFDO1FBRWhFLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUN0QyxNQUFNOzs7O1FBQUMsVUFBQSxDQUFDLElBQUksT0FBQSxDQUFDLENBQUMsWUFBWSxZQUFZLENBQUMsRUFBM0IsQ0FBMkIsRUFBQyxFQUN4QyxHQUFHOzs7O1FBQXFDLFVBQUMsWUFBcUMsSUFBSyxPQUFBLFlBQVksQ0FBQyxJQUFJLEVBQWpCLENBQWlCLEVBQUMsRUFDckcsR0FBRzs7OztRQUF5QixVQUFBLFNBQVM7WUFDbkMsNENBQTRDO1lBQzVDLElBQUksQ0FBQyxLQUFJLENBQUMsS0FBSyxDQUFDLGNBQWMsQ0FBQyxpQkFBaUIsQ0FBQyxFQUFFO2dCQUNqRCxLQUFJLENBQUMsS0FBSyxDQUFDLGlCQUFpQixDQUFDLEdBQUcsU0FBUyxDQUFDO2FBQzNDO1lBQ0QsNENBQTRDO1lBQzVDLE9BQU8sZ0JBQWdCLENBQUMsVUFBVSxDQUFDLFNBQVMsRUFBRSxZQUFZLENBQUMsQ0FBQztRQUM5RCxDQUFDLEVBQUMsRUFDRixLQUFLLENBQUMsQ0FBQyxDQUFDO1FBQ1IsNEZBQTRGO1FBQzVGLFVBQVU7OztRQUFDO1lBQ1QsS0FBSSxDQUFDLFVBQVUsQ0FBQyxpQkFBaUIsQ0FBQyxHQUFHLElBQUksQ0FBQztZQUMxQyxPQUFPLEVBQUUsQ0FBQyxZQUFZLENBQUMsQ0FBQztRQUMxQixDQUFDLEVBQUMsQ0FDSCxDQUFDO0lBQ0osQ0FBQztJQUVEOzs7OztPQUtHOzs7Ozs7OztJQUNJLDJDQUFnQjs7Ozs7OztJQUF2QixVQUF3QixpQkFBMEI7UUFDaEQsZ0RBQWdEO1FBRGxELGlCQWtDQzs7O1lBL0JPLFNBQVMsR0FBRyxnQkFBZ0IsQ0FBQyxZQUFZLEVBQUU7UUFFakQsZ0ZBQWdGO1FBQ2hGLElBQUksQ0FBQyxTQUFTLEVBQUU7WUFDZCxPQUFPLEVBQUUsQ0FBQyxJQUFJLFdBQVcsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDdEM7UUFFRCxPQUFPLEVBQUUsQ0FBQztZQUNSLGdCQUFnQixDQUFDLFdBQVcsQ0FBQyxTQUFTLENBQUM7WUFDdkMsZ0JBQWdCLENBQUMsY0FBYyxDQUFDLFNBQVMsQ0FBQztTQUMzQyxDQUFDLENBQUMsSUFBSSxDQUNMLFNBQVM7Ozs7UUFBaUQsVUFBQyxFQUFpQztnQkFBakMsMEJBQWlDLEVBQWhDLG9CQUFZLEVBQUUseUJBQWlCO1lBRXpGLHdHQUF3RztZQUN4Ryw2REFBNkQ7WUFDN0QsSUFBSSxDQUFDLGlCQUFpQixJQUFJLEtBQUksQ0FBQyxVQUFVLENBQUMsY0FBYyxDQUFDLGlCQUFpQixDQUFDLEVBQUU7Z0JBQzNFLE9BQU8sRUFBRSxDQUFDLFlBQVksQ0FBQyxDQUFDO2FBQ3pCO1lBR0Qsa0VBQWtFO1lBQ2xFLElBQUksS0FBSSxDQUFDLEtBQUssQ0FBQyxjQUFjLENBQUMsaUJBQWlCLENBQUMsRUFBRTtnQkFDaEQsT0FBTyxFQUFFLENBQUMsZ0JBQWdCLENBQUMsVUFBVSxDQUFDLEtBQUksQ0FBQyxLQUFLLENBQUMsaUJBQWlCLENBQUMsRUFBRSxZQUFZLENBQUMsQ0FBQyxDQUFDO2FBQ3JGO1lBRUQsNERBQTREO1lBQzVELE9BQU8sS0FBSSxDQUFDLGFBQWEsQ0FBQyxpQkFBaUIsRUFBRSxZQUFZLENBQUMsQ0FBQztRQUM3RCxDQUFDLEVBQUMsQ0FDSCxDQUFDO0lBR0osQ0FBQzs7Z0JBL0pGLFVBQVU7Ozs7Z0JBTkgsV0FBVzs7SUFzS25CLHVCQUFDO0NBQUEsQUFoS0QsSUFnS0M7U0EvSlksZ0JBQWdCOzs7Ozs7SUFHM0IsaUNBQWlEOzs7OztJQUNqRCxzQ0FBb0Q7Ozs7O0lBRXhDLHVDQUFnQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7U291cmNlTWFwfSBmcm9tICdAYW5ndWxhci9jb21waWxlcic7XG5pbXBvcnQge0luamVjdGFibGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtIdHRwQmFja2VuZCwgSHR0cFJlcXVlc3QsIEh0dHBSZXNwb25zZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uL2h0dHAnO1xuaW1wb3J0ICogYXMgdmxxIGZyb20gJ3ZscSc7XG5pbXBvcnQge09ic2VydmFibGUsIG9mfSBmcm9tICdyeGpzJztcbmltcG9ydCB7Y2F0Y2hFcnJvciwgZmlsdGVyLCBtYXAsIHJldHJ5LCBzd2l0Y2hNYXB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7TG9nUG9zaXRpb259IGZyb20gJy4vdHlwZXMvbG9nLXBvc2l0aW9uJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIE5HWE1hcHBlclNlcnZpY2Uge1xuXG4gIC8vIHVzZWQgdG8gY2FjaGUgc291cmNlIG1hcHNcbiAgcHJpdmF0ZSBjYWNoZTogeyBba2V5OiBzdHJpbmddOiBTb3VyY2VNYXAgfSA9IHt9O1xuICBwcml2YXRlIGVycm9yQ2FjaGU6IHsgW2tleTogc3RyaW5nXTogYm9vbGVhbiB9ID0ge307XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBodHRwQmFja2VuZDogSHR0cEJhY2tlbmQpIHtcbiAgfVxuXG4gIC8qXG4gIFN0YXRpYyBGdW5jdGlvbnNcbiAqL1xuICBwcml2YXRlIHN0YXRpYyBnZXRTdGFja0xpbmUoKTogc3RyaW5nIHtcbiAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcigpO1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIG5vaW5zcGVjdGlvbiBFeGNlcHRpb25DYXVnaHRMb2NhbGx5SlNcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH0gY2F0Y2ggKGUpIHtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGVycm9yLnN0YWNrLnNwbGl0KCdcXG4nKVs1XTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgZ2V0UG9zaXRpb24oc3RhY2tMaW5lOiBzdHJpbmcpOiBMb2dQb3NpdGlvbiB7XG4gICAgLy8gc3RyaXAgYmFzZSBwYXRoLCB0aGVuIHBhcnNlIGZpbGVuYW1lLCBsaW5lLCBhbmQgY29sdW1uXG4gICAgY29uc3QgcG9zaXRpb24gPSBzdGFja0xpbmUuc3Vic3RyaW5nKHN0YWNrTGluZS5sYXN0SW5kZXhPZignXFwvJykgKyAxLCBzdGFja0xpbmUuaW5kZXhPZignKScpKTtcbiAgICBjb25zdCBkYXRhQXJyYXkgPSBwb3NpdGlvbi5zcGxpdCgnOicpO1xuICAgIGlmIChkYXRhQXJyYXkubGVuZ3RoID09PSAzKSB7XG4gICAgICByZXR1cm4gbmV3IExvZ1Bvc2l0aW9uKGRhdGFBcnJheVswXSwgK2RhdGFBcnJheVsxXSwgK2RhdGFBcnJheVsyXSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgTG9nUG9zaXRpb24oJ3Vua25vd24nLCAwLCAwKTtcbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIGdldFRyYW5zcGlsZUxvY2F0aW9uKHN0YWNrTGluZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gc3RhY2tMaW5lLnN1YnN0cmluZyhzdGFja0xpbmUuaW5kZXhPZignKCcpICsgMSwgc3RhY2tMaW5lLmluZGV4T2YoJyknKSk7XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBnZXRNYXBGaWxlUGF0aChzdGFja0xpbmU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3QgZmlsZSA9IE5HWE1hcHBlclNlcnZpY2UuZ2V0VHJhbnNwaWxlTG9jYXRpb24oc3RhY2tMaW5lKTtcbiAgICBjb25zdCBtYXBGdWxsUGF0aCA9IGZpbGUuc3Vic3RyaW5nKDAsIGZpbGUubGFzdEluZGV4T2YoJzonKSk7XG4gICAgcmV0dXJuIG1hcEZ1bGxQYXRoLnN1YnN0cmluZygwLCBtYXBGdWxsUGF0aC5sYXN0SW5kZXhPZignOicpKSArICcubWFwJztcbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIGdldE1hcHBpbmcoc291cmNlTWFwOiBTb3VyY2VNYXAsIHBvc2l0aW9uOiBMb2dQb3NpdGlvbik6IExvZ1Bvc2l0aW9uIHtcbiAgICAvLyA9PiAnOycgaW5kaWNhdGVzIGVuZCBvZiBhIGxpbmVcbiAgICAvLyA9PiAnLCcgc2VwYXJhdGVzIG1hcHBpbmdzIGluIGEgbGluZVxuICAgIC8vIGRlY29kZWQgbWFwcGluZyA9PiBbIGdlbmVyYXRlZENvZGVDb2x1bW4sIHNvdXJjZUZpbGVJbmRleCwgc291cmNlQ29kZUxpbmUsIHNvdXJjZUNvZGVDb2x1bW4sIG5hbWVJbmRleCBdXG4gICAgbGV0IHNvdXJjZUZpbGVJbmRleCA9IDAsICAgLy8gc2Vjb25kIGZpZWxkXG4gICAgICBzb3VyY2VDb2RlTGluZSA9IDAsICAgIC8vIHRoaXJkIGZpZWxkXG4gICAgICBzb3VyY2VDb2RlQ29sdW1uID0gMDsgIC8vIGZvdXJ0aCBmaWVsZFxuXG4gICAgY29uc3QgbGluZXMgPSBzb3VyY2VNYXAubWFwcGluZ3Muc3BsaXQoJzsnKTtcblxuICAgIGZvciAobGV0IGxpbmVJbmRleCA9IDA7IGxpbmVJbmRleCA8IGxpbmVzLmxlbmd0aDsgbGluZUluZGV4KyspIHtcbiAgICAgIC8vIHJlc2V0IGNvbHVtbiBwb3NpdGlvbiB0byAwIGFmdGVyIGVhY2ggbGluZVxuICAgICAgbGV0IGdlbmVyYXRlZENvZGVDb2x1bW4gPSAwO1xuICAgICAgLy8gZGVjb2RlIHNlY3Rpb25zIGluIGxpbmVcbiAgICAgIGNvbnN0IGNvbHVtbnMgPSBsaW5lc1tsaW5lSW5kZXhdLnNwbGl0KCcsJyk7XG5cbiAgICAgIGZvciAobGV0IGNvbHVtbkluZGV4ID0gMDsgY29sdW1uSW5kZXggPCBjb2x1bW5zLmxlbmd0aDsgY29sdW1uSW5kZXgrKykge1xuICAgICAgICBjb25zdCBkZWNvZGVkU2VjdGlvbiA9IHZscS5kZWNvZGUoY29sdW1uc1tjb2x1bW5JbmRleF0pO1xuICAgICAgICBpZiAoZGVjb2RlZFNlY3Rpb24ubGVuZ3RoID49IDQpIHtcbiAgICAgICAgICAvLyB1cGRhdGUgcmVsYXRpdmUgcG9zaXRpb25zXG4gICAgICAgICAgZ2VuZXJhdGVkQ29kZUNvbHVtbiArPSBkZWNvZGVkU2VjdGlvblswXTtcbiAgICAgICAgICBzb3VyY2VGaWxlSW5kZXggKz0gZGVjb2RlZFNlY3Rpb25bMV07XG4gICAgICAgICAgc291cmNlQ29kZUxpbmUgKz0gZGVjb2RlZFNlY3Rpb25bMl07XG4gICAgICAgICAgc291cmNlQ29kZUNvbHVtbiArPSBkZWNvZGVkU2VjdGlvblszXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNoZWNrIGlmIG1hdGNoaW5nIG1hcFxuICAgICAgICBpZiAobGluZUluZGV4ID09PSBwb3NpdGlvbi5saW5lTnVtYmVyKSB7XG4gICAgICAgICAgaWYgKGdlbmVyYXRlZENvZGVDb2x1bW4gPT09IHBvc2l0aW9uLmNvbHVtbk51bWJlcikge1xuICAgICAgICAgICAgLy8gbWF0Y2hpbmcgY29sdW1uIGFuZCBsaW5lIGZvdW5kXG4gICAgICAgICAgICByZXR1cm4gbmV3IExvZ1Bvc2l0aW9uKHNvdXJjZU1hcC5zb3VyY2VzW3NvdXJjZUZpbGVJbmRleF0sIHNvdXJjZUNvZGVMaW5lLCBzb3VyY2VDb2RlQ29sdW1uKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNvbHVtbkluZGV4ICsgMSA9PT0gY29sdW1ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIG1hdGNoaW5nIGNvbHVtbiBub3QgZm91bmQsIGJ1dCBsaW5lIGlzIGNvcnJlY3RcbiAgICAgICAgICAgIHJldHVybiBuZXcgTG9nUG9zaXRpb24oc291cmNlTWFwLnNvdXJjZXNbc291cmNlRmlsZUluZGV4XSwgc291cmNlQ29kZUxpbmUsIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBmYWlsZWQgaWYgcmVhY2hlZFxuICAgIHJldHVybiBuZXcgTG9nUG9zaXRpb24oJ3Vua25vd24nLCAwLCAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBkb2VzIHRoZSBodHRwIGdldCByZXF1ZXN0IHRvIGdldCB0aGUgc291cmNlIG1hcFxuICAgKiBAcGFyYW0gc291cmNlTWFwTG9jYXRpb25cbiAgICogQHBhcmFtIGRpc3RQb3NpdGlvblxuICAgKi9cbiAgcHJpdmF0ZSBfZ2V0U291cmNlTWFwKHNvdXJjZU1hcExvY2F0aW9uOiBzdHJpbmcsIGRpc3RQb3NpdGlvbjogTG9nUG9zaXRpb24pOiBPYnNlcnZhYmxlPExvZ1Bvc2l0aW9uPiB7XG4gICAgY29uc3QgcmVxID0gbmV3IEh0dHBSZXF1ZXN0PFNvdXJjZU1hcD4oJ0dFVCcsIHNvdXJjZU1hcExvY2F0aW9uKTtcblxuICAgIHJldHVybiB0aGlzLmh0dHBCYWNrZW5kLmhhbmRsZShyZXEpLnBpcGUoXG4gICAgICBmaWx0ZXIoZSA9PiAoZSBpbnN0YW5jZW9mIEh0dHBSZXNwb25zZSkpLFxuICAgICAgbWFwPEh0dHBSZXNwb25zZTxTb3VyY2VNYXA+LCBTb3VyY2VNYXA+KChodHRwUmVzcG9uc2U6IEh0dHBSZXNwb25zZTxTb3VyY2VNYXA+KSA9PiBodHRwUmVzcG9uc2UuYm9keSksXG4gICAgICBtYXA8U291cmNlTWFwLCBMb2dQb3NpdGlvbj4oc291cmNlTWFwID0+IHtcbiAgICAgICAgLy8gc3RvcmUgZmlsZSBpbiBjYWNoZSBpZiBub3QgYWxyZWFkeSBzdG9yZWRcbiAgICAgICAgaWYgKCF0aGlzLmNhY2hlLmhhc093blByb3BlcnR5KHNvdXJjZU1hcExvY2F0aW9uKSkge1xuICAgICAgICAgIHRoaXMuY2FjaGVbc291cmNlTWFwTG9jYXRpb25dID0gc291cmNlTWFwO1xuICAgICAgICB9XG4gICAgICAgIC8vIG1hcCBnZW5lcmF0ZWQgcG9zaXRpb24gdG8gc291cmNlIHBvc2l0aW9uXG4gICAgICAgIHJldHVybiBOR1hNYXBwZXJTZXJ2aWNlLmdldE1hcHBpbmcoc291cmNlTWFwLCBkaXN0UG9zaXRpb24pO1xuICAgICAgfSksXG4gICAgICByZXRyeSgzKSxcbiAgICAgIC8vIGlmIHRoZXJlIGlzIGFuIGVycm9yIGdldHRpbmcgdGhlIHNvdXJjZSwgbWFwIGZhbGwgYmFjayB0byB0aGUgZmlsZW5hbWUgYW5kIGxpbmUgbnVtYmVyIG9mXG4gICAgICBjYXRjaEVycm9yKCgpID0+IHtcbiAgICAgICAgdGhpcy5lcnJvckNhY2hlW3NvdXJjZU1hcExvY2F0aW9uXSA9IHRydWU7XG4gICAgICAgIHJldHVybiBvZihkaXN0UG9zaXRpb24pO1xuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIExvZ1Bvc2l0aW9uIGZvciB0aGUgY3VycmVudCBsb2dcbiAgICogSWYgc291cmNlTWFwcyBhcmUgZW5hYmxlZCwgaXQgYXR0ZW1wcyB0byBnZXQgdGhlIHNvdXJjZSBtYXAgZnJvbSB0aGUgc2VydmVyLCBhbmQgdXNlIHRoYXQgdG8gcGFyc2UgdGhlIGZpbGUgbmFtZVxuICAgKiBhbmQgbnVtYmVyIG9mIHRoZSBjYWxsXG4gICAqIEBwYXJhbSBzb3VyY2VNYXBzRW5hYmxlZFxuICAgKi9cbiAgcHVibGljIGdldENhbGxlckRldGFpbHMoc291cmNlTWFwc0VuYWJsZWQ6IGJvb2xlYW4pOiBPYnNlcnZhYmxlPExvZ1Bvc2l0aW9uPiB7XG4gICAgLy8gcGFyc2UgZ2VuZXJhdGVkIGZpbGUgbWFwcGluZyBmcm9tIHN0YWNrIHRyYWNlXG5cbiAgICBjb25zdCBzdGFja0xpbmUgPSBOR1hNYXBwZXJTZXJ2aWNlLmdldFN0YWNrTGluZSgpO1xuXG4gICAgLy8gaWYgd2Ugd2VyZSBub3QgYWJsZSB0byBwYXJzZSB0aGUgc3RhY2tMaW5lLCBqdXN0IHJldHVybiBhbiBlbXB0eSBMb2cgUG9zaXRpb25cbiAgICBpZiAoIXN0YWNrTGluZSkge1xuICAgICAgcmV0dXJuIG9mKG5ldyBMb2dQb3NpdGlvbignJywgMCwgMCkpO1xuICAgIH1cblxuICAgIHJldHVybiBvZihbXG4gICAgICBOR1hNYXBwZXJTZXJ2aWNlLmdldFBvc2l0aW9uKHN0YWNrTGluZSksXG4gICAgICBOR1hNYXBwZXJTZXJ2aWNlLmdldE1hcEZpbGVQYXRoKHN0YWNrTGluZSlcbiAgICBdKS5waXBlKFxuICAgICAgc3dpdGNoTWFwPFtMb2dQb3NpdGlvbiwgc3RyaW5nXSwgT2JzZXJ2YWJsZTxMb2dQb3NpdGlvbj4+KChbZGlzdFBvc2l0aW9uLCBzb3VyY2VNYXBMb2NhdGlvbl0pID0+IHtcblxuICAgICAgICAvLyBpZiBzb3VyY2UgbWFwcyBhcmUgbm90IGVuYWJsZWQsIG9yIGlmIHdlJ3ZlIHByZXZpb3VzbHkgdHJpZWQgdG8gZ2V0IHRoZSBzb3VyY2UgbWFwcywgYnV0IHRoZXkgZmFpbGVkLFxuICAgICAgICAvLyB0aGVuIGp1c3QgdXNlIHRoZSBwb3NpdGlvbiBvZiB0aGUgSlMgaW5zdGVhZCBvZiB0aGUgc291cmNlXG4gICAgICAgIGlmICghc291cmNlTWFwc0VuYWJsZWQgfHwgdGhpcy5lcnJvckNhY2hlLmhhc093blByb3BlcnR5KHNvdXJjZU1hcExvY2F0aW9uKSkge1xuICAgICAgICAgIHJldHVybiBvZihkaXN0UG9zaXRpb24pO1xuICAgICAgICB9XG5cblxuICAgICAgICAvLyBjaGVjayBpZiB3ZSBoYXZlIG1hcCBoYXMgYWxyZWFkeSwgb3RoZXJ3aXNlIHJlcXVlc3QgZnJvbSBzZXJ2ZXJcbiAgICAgICAgaWYgKHRoaXMuY2FjaGUuaGFzT3duUHJvcGVydHkoc291cmNlTWFwTG9jYXRpb24pKSB7XG4gICAgICAgICAgcmV0dXJuIG9mKE5HWE1hcHBlclNlcnZpY2UuZ2V0TWFwcGluZyh0aGlzLmNhY2hlW3NvdXJjZU1hcExvY2F0aW9uXSwgZGlzdFBvc2l0aW9uKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaW5hbGx5IHRyeSB0byBnZXQgdGhlIHNvdXJjZSBtYXAgYW5kIHJldHVybiB0aGUgcG9zaXRpb25cbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFNvdXJjZU1hcChzb3VyY2VNYXBMb2NhdGlvbiwgZGlzdFBvc2l0aW9uKTtcbiAgICAgIH0pXG4gICAgKTtcblxuXG4gIH1cbn1cblxuXG5cblxuIl19