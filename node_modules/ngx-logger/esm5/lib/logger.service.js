/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Injectable } from '@angular/core';
import { HttpHeaders, HttpParams } from '@angular/common/http';
import { NGXLoggerHttpService } from './http.service';
import { NgxLoggerLevel } from './types/logger-level.enum';
import { LoggerConfig } from './logger.config';
import { NGXLoggerConfigEngine } from './config.engine';
import { NGXLoggerUtils } from './utils/logger.utils';
import { NGXMapperService } from './mapper.service';
/** @type {?} */
export var Levels = [
    'TRACE',
    'DEBUG',
    'INFO',
    'LOG',
    'WARN',
    'ERROR',
    'FATAL',
    'OFF'
];
var NGXLogger = /** @class */ (function () {
    function NGXLogger(mapperService, httpService, loggerConfig) {
        this.mapperService = mapperService;
        this.httpService = httpService;
        this._withCredentials = false;
        this._isIE = navigator && navigator.userAgent &&
            !!(navigator.userAgent.indexOf('MSIE') !== -1 || navigator.userAgent.match(/Trident\//) || navigator.userAgent.match(/Edge\//));
        // each instance of the logger should have their own config engine
        this.config = new NGXLoggerConfigEngine(loggerConfig);
        this._logFunc = this._isIE ? this._logIE.bind(this) : this._logModern.bind(this);
    }
    /**
     * @param {?} message
     * @param {...?} additional
     * @return {?}
     */
    NGXLogger.prototype.trace = /**
     * @param {?} message
     * @param {...?} additional
     * @return {?}
     */
    function (message) {
        var additional = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            additional[_i - 1] = arguments[_i];
        }
        this._log(NgxLoggerLevel.TRACE, message, additional);
    };
    /**
     * @param {?} message
     * @param {...?} additional
     * @return {?}
     */
    NGXLogger.prototype.debug = /**
     * @param {?} message
     * @param {...?} additional
     * @return {?}
     */
    function (message) {
        var additional = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            additional[_i - 1] = arguments[_i];
        }
        this._log(NgxLoggerLevel.DEBUG, message, additional);
    };
    /**
     * @param {?} message
     * @param {...?} additional
     * @return {?}
     */
    NGXLogger.prototype.info = /**
     * @param {?} message
     * @param {...?} additional
     * @return {?}
     */
    function (message) {
        var additional = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            additional[_i - 1] = arguments[_i];
        }
        this._log(NgxLoggerLevel.INFO, message, additional);
    };
    /**
     * @param {?} message
     * @param {...?} additional
     * @return {?}
     */
    NGXLogger.prototype.log = /**
     * @param {?} message
     * @param {...?} additional
     * @return {?}
     */
    function (message) {
        var additional = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            additional[_i - 1] = arguments[_i];
        }
        this._log(NgxLoggerLevel.LOG, message, additional);
    };
    /**
     * @param {?} message
     * @param {...?} additional
     * @return {?}
     */
    NGXLogger.prototype.warn = /**
     * @param {?} message
     * @param {...?} additional
     * @return {?}
     */
    function (message) {
        var additional = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            additional[_i - 1] = arguments[_i];
        }
        this._log(NgxLoggerLevel.WARN, message, additional);
    };
    /**
     * @param {?} message
     * @param {...?} additional
     * @return {?}
     */
    NGXLogger.prototype.error = /**
     * @param {?} message
     * @param {...?} additional
     * @return {?}
     */
    function (message) {
        var additional = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            additional[_i - 1] = arguments[_i];
        }
        this._log(NgxLoggerLevel.ERROR, message, additional);
    };
    /**
     * @param {?} message
     * @param {...?} additional
     * @return {?}
     */
    NGXLogger.prototype.fatal = /**
     * @param {?} message
     * @param {...?} additional
     * @return {?}
     */
    function (message) {
        var additional = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            additional[_i - 1] = arguments[_i];
        }
        this._log(NgxLoggerLevel.FATAL, message, additional);
    };
    /**
     * @param {?} headers
     * @return {?}
     */
    NGXLogger.prototype.setCustomHttpHeaders = /**
     * @param {?} headers
     * @return {?}
     */
    function (headers) {
        this._customHttpHeaders = headers;
    };
    /**
     * @param {?} params
     * @return {?}
     */
    NGXLogger.prototype.setCustomParams = /**
     * @param {?} params
     * @return {?}
     */
    function (params) {
        this._customParams = params;
    };
    /**
     * @param {?} withCredentials
     * @return {?}
     */
    NGXLogger.prototype.setWithCredentialsOptionValue = /**
     * @param {?} withCredentials
     * @return {?}
     */
    function (withCredentials) {
        this._withCredentials = withCredentials;
    };
    /**
     * @param {?} monitor
     * @return {?}
     */
    NGXLogger.prototype.registerMonitor = /**
     * @param {?} monitor
     * @return {?}
     */
    function (monitor) {
        this._loggerMonitor = monitor;
    };
    /**
     * @param {?} config
     * @return {?}
     */
    NGXLogger.prototype.updateConfig = /**
     * @param {?} config
     * @return {?}
     */
    function (config) {
        this.config.updateConfig(config);
    };
    /**
     * @return {?}
     */
    NGXLogger.prototype.getConfigSnapshot = /**
     * @return {?}
     */
    function () {
        return this.config.getConfig();
    };
    /**
     * @private
     * @param {?} level
     * @param {?} metaString
     * @param {?} message
     * @param {?} additional
     * @return {?}
     */
    NGXLogger.prototype._logIE = /**
     * @private
     * @param {?} level
     * @param {?} metaString
     * @param {?} message
     * @param {?} additional
     * @return {?}
     */
    function (level, metaString, message, additional) {
        // Coloring doesn't work in IE
        // make sure additional isn't null or undefined so that ...additional doesn't error
        additional = additional || [];
        switch (level) {
            case NgxLoggerLevel.WARN:
                console.warn.apply(console, tslib_1.__spread([metaString + " ", message], additional));
                break;
            case NgxLoggerLevel.ERROR:
            case NgxLoggerLevel.FATAL:
                console.error.apply(console, tslib_1.__spread([metaString + " ", message], additional));
                break;
            case NgxLoggerLevel.INFO:
                console.info.apply(console, tslib_1.__spread([metaString + " ", message], additional));
                break;
            default:
                console.log.apply(console, tslib_1.__spread([metaString + " ", message], additional));
        }
    };
    /**
     * @private
     * @param {?} level
     * @param {?} metaString
     * @param {?} message
     * @param {?} additional
     * @return {?}
     */
    NGXLogger.prototype._logModern = /**
     * @private
     * @param {?} level
     * @param {?} metaString
     * @param {?} message
     * @param {?} additional
     * @return {?}
     */
    function (level, metaString, message, additional) {
        /** @type {?} */
        var color = NGXLoggerUtils.getColor(level);
        // make sure additional isn't null or undefined so that ...additional doesn't error
        additional = additional || [];
        switch (level) {
            case NgxLoggerLevel.WARN:
                console.warn.apply(console, tslib_1.__spread(["%c" + metaString, "color:" + color, message], additional));
                break;
            case NgxLoggerLevel.ERROR:
            case NgxLoggerLevel.FATAL:
                console.error.apply(console, tslib_1.__spread(["%c" + metaString, "color:" + color, message], additional));
                break;
            case NgxLoggerLevel.INFO:
                console.info.apply(console, tslib_1.__spread(["%c" + metaString, "color:" + color, message], additional));
                break;
            //  Disabling console.trace since the stack trace is not helpful. it is showing the stack trace of
            // the console.trace statement
            // case NgxLoggerLevel.TRACE:
            //   console.trace(`%c${metaString}`, `color:${color}`, message, ...additional);
            //   break;
            //  Disabling console.debug, because Has this hidden by default.
            // case NgxLoggerLevel.DEBUG:
            //   console.debug(`%c${metaString}`, `color:${color}`, message, ...additional);
            //   break;
            default:
                console.log.apply(console, tslib_1.__spread(["%c" + metaString, "color:" + color, message], additional));
        }
    };
    /**
     * @private
     * @param {?} level
     * @param {?} message
     * @param {?=} additional
     * @param {?=} logOnServer
     * @return {?}
     */
    NGXLogger.prototype._log = /**
     * @private
     * @param {?} level
     * @param {?} message
     * @param {?=} additional
     * @param {?=} logOnServer
     * @return {?}
     */
    function (level, message, additional, logOnServer) {
        var _this = this;
        if (additional === void 0) { additional = []; }
        if (logOnServer === void 0) { logOnServer = true; }
        /** @type {?} */
        var config = this.config.getConfig();
        /** @type {?} */
        var isLog2Server = logOnServer && config.serverLoggingUrl && level >= config.serverLogLevel;
        /** @type {?} */
        var isLogLevelEnabled = level >= config.level;
        if (!(message && (isLog2Server || isLogLevelEnabled))) {
            return;
        }
        /** @type {?} */
        var logLevelString = Levels[level];
        message = NGXLoggerUtils.prepareMessage(message);
        // only use validated parameters for HTTP requests
        /** @type {?} */
        var validatedAdditionalParameters = NGXLoggerUtils.prepareAdditionalParameters(additional);
        /** @type {?} */
        var timestamp = new Date().toISOString();
        // const callerDetails = NGXLoggerUtils.getCallerDetails();
        this.mapperService.getCallerDetails(config.enableSourceMaps).subscribe((/**
         * @param {?} callerDetails
         * @return {?}
         */
        function (callerDetails) {
            /** @type {?} */
            var logObject = {
                message: message,
                additional: validatedAdditionalParameters,
                level: level,
                timestamp: timestamp,
                fileName: callerDetails.fileName,
                lineNumber: callerDetails.lineNumber.toString()
            };
            if (_this._loggerMonitor && isLogLevelEnabled) {
                _this._loggerMonitor.onLog(logObject);
            }
            if (isLog2Server) {
                // make sure the stack gets sent to the server
                message = message instanceof Error ? message.stack : message;
                logObject.message = message;
                /** @type {?} */
                var headers = _this._customHttpHeaders || new HttpHeaders();
                headers.set('Content-Type', 'application/json');
                /** @type {?} */
                var options = {
                    headers: headers,
                    params: _this._customParams || new HttpParams(),
                    responseType: config.httpResponseType || 'json',
                    withCredentials: _this._withCredentials
                };
                // Allow logging on server even if client log level is off
                _this.httpService.logOnServer(config.serverLoggingUrl, logObject, options).subscribe((/**
                 * @param {?} res
                 * @return {?}
                 */
                function (res) {
                    // I don't think we should do anything on success
                }), (/**
                 * @param {?} error
                 * @return {?}
                 */
                function (error) {
                    _this._log(NgxLoggerLevel.ERROR, "FAILED TO LOG ON SERVER: " + message, [error], false);
                }));
            }
            // if no message or the log level is less than the environ
            if (isLogLevelEnabled && !config.disableConsoleLogging) {
                /** @type {?} */
                var metaString = NGXLoggerUtils.prepareMetaString(timestamp, logLevelString, callerDetails.fileName, callerDetails.lineNumber.toString());
                return _this._logFunc(level, metaString, message, additional);
            }
        }));
    };
    NGXLogger.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    NGXLogger.ctorParameters = function () { return [
        { type: NGXMapperService },
        { type: NGXLoggerHttpService },
        { type: LoggerConfig }
    ]; };
    return NGXLogger;
}());
export { NGXLogger };
if (false) {
    /**
     * @type {?}
     * @private
     */
    NGXLogger.prototype._isIE;
    /**
     * @type {?}
     * @private
     */
    NGXLogger.prototype._logFunc;
    /**
     * @type {?}
     * @private
     */
    NGXLogger.prototype.config;
    /**
     * @type {?}
     * @private
     */
    NGXLogger.prototype._customHttpHeaders;
    /**
     * @type {?}
     * @private
     */
    NGXLogger.prototype._customParams;
    /**
     * @type {?}
     * @private
     */
    NGXLogger.prototype._withCredentials;
    /**
     * @type {?}
     * @private
     */
    NGXLogger.prototype._loggerMonitor;
    /**
     * @type {?}
     * @private
     */
    NGXLogger.prototype.mapperService;
    /**
     * @type {?}
     * @private
     */
    NGXLogger.prototype.httpService;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibG9nZ2VyLnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9uZ3gtbG9nZ2VyLyIsInNvdXJjZXMiOlsibGliL2xvZ2dlci5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsT0FBTyxFQUFVLFVBQVUsRUFBZSxNQUFNLGVBQWUsQ0FBQztBQUNoRSxPQUFPLEVBQXFCLFdBQVcsRUFBRSxVQUFVLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUdsRixPQUFPLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUV0RCxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sMkJBQTJCLENBQUM7QUFDM0QsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQy9DLE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQ3hELE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUd0RCxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQzs7QUFFcEQsTUFBTSxLQUFPLE1BQU0sR0FBRztJQUNwQixPQUFPO0lBQ1AsT0FBTztJQUNQLE1BQU07SUFDTixLQUFLO0lBQ0wsTUFBTTtJQUNOLE9BQU87SUFDUCxPQUFPO0lBQ1AsS0FBSztDQUNOO0FBR0Q7SUFXRSxtQkFBNkIsYUFBK0IsRUFBbUIsV0FBaUMsRUFDcEcsWUFBMEI7UUFEVCxrQkFBYSxHQUFiLGFBQWEsQ0FBa0I7UUFBbUIsZ0JBQVcsR0FBWCxXQUFXLENBQXNCO1FBSnhHLHFCQUFnQixHQUFZLEtBQUssQ0FBQztRQU14QyxJQUFJLENBQUMsS0FBSyxHQUFHLFNBQVMsSUFBSSxTQUFTLENBQUMsU0FBUztZQUMzQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsSUFBSSxTQUFTLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxX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LENBQUMsUUFBUSxDQUFDLEtBQUssRUFBRSxVQUFVLEVBQUUsT0FBTyxFQUFFLFVBQVUsQ0FBQyxDQUFDO2FBQzlEO1FBQ0gsQ0FBQyxFQUFDLENBQUM7SUFDTCxDQUFDOztnQkFwTUYsVUFBVTs7OztnQkFkRixnQkFBZ0I7Z0JBUmhCLG9CQUFvQjtnQkFHcEIsWUFBWTs7SUF3TnJCLGdCQUFDO0NBQUEsQUFyTUQsSUFxTUM7U0FwTVksU0FBUzs7Ozs7O0lBQ3BCLDBCQUFnQzs7Ozs7SUFDaEMsNkJBQW9DOzs7OztJQUNwQywyQkFBc0M7Ozs7O0lBQ3RDLHVDQUF3Qzs7Ozs7SUFDeEMsa0NBQWtDOzs7OztJQUNsQyxxQ0FBMEM7Ozs7O0lBRTFDLG1DQUF5Qzs7Ozs7SUFFN0Isa0NBQWdEOzs7OztJQUFFLGdDQUFrRCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdCwgSW5qZWN0YWJsZSwgUExBVEZPUk1fSUQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEh0dHBFcnJvclJlc3BvbnNlLCBIdHRwSGVhZGVycywgSHR0cFBhcmFtcyB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbi9odHRwJztcbmltcG9ydCB7IGlzUGxhdGZvcm1Ccm93c2VyIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcblxuaW1wb3J0IHsgTkdYTG9nZ2VySHR0cFNlcnZpY2UgfSBmcm9tICcuL2h0dHAuc2VydmljZSc7XG5pbXBvcnQge0xvZ1Bvc2l0aW9ufSBmcm9tICcuL3R5cGVzL2xvZy1wb3NpdGlvbic7XG5pbXBvcnQgeyBOZ3hMb2dnZXJMZXZlbCB9IGZyb20gJy4vdHlwZXMvbG9nZ2VyLWxldmVsLmVudW0nO1xuaW1wb3J0IHsgTG9nZ2VyQ29uZmlnIH0gZnJvbSAnLi9sb2dnZXIuY29uZmlnJztcbmltcG9ydCB7IE5HWExvZ2dlckNvbmZpZ0VuZ2luZSB9IGZyb20gJy4vY29uZmlnLmVuZ2luZSc7XG5pbXBvcnQgeyBOR1hMb2dnZXJVdGlscyB9IGZyb20gJy4vdXRpbHMvbG9nZ2VyLnV0aWxzJztcbmltcG9ydCB7IE5HWExvZ2dlck1vbml0b3IgfSBmcm9tICcuL2xvZ2dlci1tb25pdG9yJztcbmltcG9ydCB7IE5HWExvZ0ludGVyZmFjZSB9IGZyb20gJy4vdHlwZXMvbmd4LWxvZy5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgTkdYTWFwcGVyU2VydmljZSB9IGZyb20gJy4vbWFwcGVyLnNlcnZpY2UnO1xuXG5leHBvcnQgY29uc3QgTGV2ZWxzID0gW1xuICAnVFJBQ0UnLFxuICAnREVCVUcnLFxuICAnSU5GTycsXG4gICdMT0cnLFxuICAnV0FSTicsXG4gICdFUlJPUicsXG4gICdGQVRBTCcsXG4gICdPRkYnXG5dO1xuXG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBOR1hMb2dnZXIge1xuICBwcml2YXRlIHJlYWRvbmx5IF9pc0lFOiBib29sZWFuO1xuICBwcml2YXRlIHJlYWRvbmx5IF9sb2dGdW5jOiBGdW5jdGlvbjtcbiAgcHJpdmF0ZSBjb25maWc6IE5HWExvZ2dlckNvbmZpZ0VuZ2luZTtcbiAgcHJpdmF0ZSBfY3VzdG9tSHR0cEhlYWRlcnM6IEh0dHBIZWFkZXJzO1xuICBwcml2YXRlIF9jdXN0b21QYXJhbXM6IEh0dHBQYXJhbXM7XG4gIHByaXZhdGUgX3dpdGhDcmVkZW50aWFsczogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIHByaXZhdGUgX2xvZ2dlck1vbml0b3I6IE5HWExvZ2dlck1vbml0b3I7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBtYXBwZXJTZXJ2aWNlOiBOR1hNYXBwZXJTZXJ2aWNlLCBwcml2YXRlIHJlYWRvbmx5IGh0dHBTZXJ2aWNlOiBOR1hMb2dnZXJIdHRwU2VydmljZSxcbiAgICAgICAgICAgICAgbG9nZ2VyQ29uZmlnOiBMb2dnZXJDb25maWcpIHtcbiAgICB0aGlzLl9pc0lFID0gbmF2aWdhdG9yICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiZcbiAgICAgICEhKG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignTVNJRScpICE9PSAtMSB8fCBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9UcmlkZW50XFwvLykgfHwgbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvRWRnZVxcLy8pKTtcblxuICAgIC8vIGVhY2ggaW5zdGFuY2Ugb2YgdGhlIGxvZ2dlciBzaG91bGQgaGF2ZSB0aGVpciBvd24gY29uZmlnIGVuZ2luZVxuICAgIHRoaXMuY29uZmlnID0gbmV3IE5HWExvZ2dlckNvbmZpZ0VuZ2luZShsb2dnZXJDb25maWcpO1xuXG4gICAgdGhpcy5fbG9nRnVuYyA9IHRoaXMuX2lzSUUgPyB0aGlzLl9sb2dJRS5iaW5kKHRoaXMpIDogdGhpcy5fbG9nTW9kZXJuLmJpbmQodGhpcyk7XG5cbiAgfVxuXG4gIHB1YmxpYyB0cmFjZShtZXNzYWdlLCAuLi5hZGRpdGlvbmFsOiBhbnlbXSk6IHZvaWQge1xuICAgIHRoaXMuX2xvZyhOZ3hMb2dnZXJMZXZlbC5UUkFDRSwgbWVzc2FnZSwgYWRkaXRpb25hbCk7XG4gIH1cblxuICBwdWJsaWMgZGVidWcobWVzc2FnZSwgLi4uYWRkaXRpb25hbDogYW55W10pOiB2b2lkIHtcbiAgICB0aGlzLl9sb2coTmd4TG9nZ2VyTGV2ZWwuREVCVUcsIG1lc3NhZ2UsIGFkZGl0aW9uYWwpO1xuICB9XG5cbiAgcHVibGljIGluZm8obWVzc2FnZSwgLi4uYWRkaXRpb25hbDogYW55W10pOiB2b2lkIHtcbiAgICB0aGlzLl9sb2coTmd4TG9nZ2VyTGV2ZWwuSU5GTywgbWVzc2FnZSwgYWRkaXRpb25hbCk7XG4gIH1cblxuICBwdWJsaWMgbG9nKG1lc3NhZ2UsIC4uLmFkZGl0aW9uYWw6IGFueVtdKTogdm9pZCB7XG4gICAgdGhpcy5fbG9nKE5neExvZ2dlckxldmVsLkxPRywgbWVzc2FnZSwgYWRkaXRpb25hbCk7XG4gIH1cblxuICBwdWJsaWMgd2FybihtZXNzYWdlLCAuLi5hZGRpdGlvbmFsOiBhbnlbXSk6IHZvaWQge1xuICAgIHRoaXMuX2xvZyhOZ3hMb2dnZXJMZXZlbC5XQVJOLCBtZXNzYWdlLCBhZGRpdGlvbmFsKTtcbiAgfVxuXG4gIHB1YmxpYyBlcnJvcihtZXNzYWdlLCAuLi5hZGRpdGlvbmFsOiBhbnlbXSk6IHZvaWQge1xuICAgIHRoaXMuX2xvZyhOZ3hMb2dnZXJMZXZlbC5FUlJPUiwgbWVzc2FnZSwgYWRkaXRpb25hbCk7XG4gIH1cblxuICBwdWJsaWMgZmF0YWwobWVzc2FnZSwgLi4uYWRkaXRpb25hbDogYW55W10pOiB2b2lkIHtcbiAgICB0aGlzLl9sb2coTmd4TG9nZ2VyTGV2ZWwuRkFUQUwsIG1lc3NhZ2UsIGFkZGl0aW9uYWwpO1xuICB9XG5cbiAgcHVibGljIHNldEN1c3RvbUh0dHBIZWFkZXJzKGhlYWRlcnM6IEh0dHBIZWFkZXJzKSB7XG4gICAgdGhpcy5fY3VzdG9tSHR0cEhlYWRlcnMgPSBoZWFkZXJzO1xuICB9XG5cbiAgcHVibGljIHNldEN1c3RvbVBhcmFtcyhwYXJhbXM6IEh0dHBQYXJhbXMpIHtcbiAgICB0aGlzLl9jdXN0b21QYXJhbXMgPSBwYXJhbXM7XG4gIH1cblxuICBwdWJsaWMgc2V0V2l0aENyZWRlbnRpYWxzT3B0aW9uVmFsdWUod2l0aENyZWRlbnRpYWxzOiBib29sZWFuKSB7XG4gICAgdGhpcy5fd2l0aENyZWRlbnRpYWxzID0gd2l0aENyZWRlbnRpYWxzO1xuICB9XG5cbiAgcHVibGljIHJlZ2lzdGVyTW9uaXRvcihtb25pdG9yOiBOR1hMb2dnZXJNb25pdG9yKSB7XG4gICAgdGhpcy5fbG9nZ2VyTW9uaXRvciA9IG1vbml0b3I7XG4gIH1cblxuICBwdWJsaWMgdXBkYXRlQ29uZmlnKGNvbmZpZzogTG9nZ2VyQ29uZmlnKSB7XG4gICAgdGhpcy5jb25maWcudXBkYXRlQ29uZmlnKGNvbmZpZyk7XG4gIH1cblxuICBwdWJsaWMgZ2V0Q29uZmlnU25hcHNob3QoKTogTG9nZ2VyQ29uZmlnIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWcuZ2V0Q29uZmlnKCk7XG4gIH1cblxuICBwcml2YXRlIF9sb2dJRShsZXZlbDogTmd4TG9nZ2VyTGV2ZWwsIG1ldGFTdHJpbmc6IHN0cmluZywgbWVzc2FnZTogc3RyaW5nLCBhZGRpdGlvbmFsOiBhbnlbXSk6IHZvaWQge1xuXG4gICAgLy8gQ29sb3JpbmcgZG9lc24ndCB3b3JrIGluIElFXG4gICAgLy8gbWFrZSBzdXJlIGFkZGl0aW9uYWwgaXNuJ3QgbnVsbCBvciB1bmRlZmluZWQgc28gdGhhdCAuLi5hZGRpdGlvbmFsIGRvZXNuJ3QgZXJyb3JcbiAgICBhZGRpdGlvbmFsID0gYWRkaXRpb25hbCB8fCBbXTtcblxuICAgIHN3aXRjaCAobGV2ZWwpIHtcbiAgICAgIGNhc2UgTmd4TG9nZ2VyTGV2ZWwuV0FSTjpcbiAgICAgICAgY29uc29sZS53YXJuKGAke21ldGFTdHJpbmd9IGAsIG1lc3NhZ2UsIC4uLmFkZGl0aW9uYWwpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgTmd4TG9nZ2VyTGV2ZWwuRVJST1I6XG4gICAgICBjYXNlIE5neExvZ2dlckxldmVsLkZBVEFMOlxuICAgICAgICBjb25zb2xlLmVycm9yKGAke21ldGFTdHJpbmd9IGAsIG1lc3NhZ2UsIC4uLmFkZGl0aW9uYWwpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgTmd4TG9nZ2VyTGV2ZWwuSU5GTzpcbiAgICAgICAgY29uc29sZS5pbmZvKGAke21ldGFTdHJpbmd9IGAsIG1lc3NhZ2UsIC4uLmFkZGl0aW9uYWwpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNvbnNvbGUubG9nKGAke21ldGFTdHJpbmd9IGAsIG1lc3NhZ2UsIC4uLmFkZGl0aW9uYWwpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX2xvZ01vZGVybihsZXZlbDogTmd4TG9nZ2VyTGV2ZWwsIG1ldGFTdHJpbmc6IHN0cmluZywgbWVzc2FnZTogc3RyaW5nLCBhZGRpdGlvbmFsOiBhbnlbXSk6IHZvaWQge1xuXG4gICAgY29uc3QgY29sb3IgPSBOR1hMb2dnZXJVdGlscy5nZXRDb2xvcihsZXZlbCk7XG5cbiAgICAvLyBtYWtlIHN1cmUgYWRkaXRpb25hbCBpc24ndCBudWxsIG9yIHVuZGVmaW5lZCBzbyB0aGF0IC4uLmFkZGl0aW9uYWwgZG9lc24ndCBlcnJvclxuICAgIGFkZGl0aW9uYWwgPSBhZGRpdGlvbmFsIHx8IFtdO1xuXG4gICAgc3dpdGNoIChsZXZlbCkge1xuICAgICAgY2FzZSBOZ3hMb2dnZXJMZXZlbC5XQVJOOlxuICAgICAgICBjb25zb2xlLndhcm4oYCVjJHttZXRhU3RyaW5nfWAsIGBjb2xvcjoke2NvbG9yfWAsIG1lc3NhZ2UsIC4uLmFkZGl0aW9uYWwpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgTmd4TG9nZ2VyTGV2ZWwuRVJST1I6XG4gICAgICBjYXNlIE5neExvZ2dlckxldmVsLkZBVEFMOlxuICAgICAgICBjb25zb2xlLmVycm9yKGAlYyR7bWV0YVN0cmluZ31gLCBgY29sb3I6JHtjb2xvcn1gLCBtZXNzYWdlLCAuLi5hZGRpdGlvbmFsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIE5neExvZ2dlckxldmVsLklORk86XG4gICAgICAgIGNvbnNvbGUuaW5mbyhgJWMke21ldGFTdHJpbmd9YCwgYGNvbG9yOiR7Y29sb3J9YCwgbWVzc2FnZSwgLi4uYWRkaXRpb25hbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gIERpc2FibGluZyBjb25zb2xlLnRyYWNlIHNpbmNlIHRoZSBzdGFjayB0cmFjZSBpcyBub3QgaGVscGZ1bC4gaXQgaXMgc2hvd2luZyB0aGUgc3RhY2sgdHJhY2Ugb2ZcbiAgICAgIC8vIHRoZSBjb25zb2xlLnRyYWNlIHN0YXRlbWVudFxuICAgICAgLy8gY2FzZSBOZ3hMb2dnZXJMZXZlbC5UUkFDRTpcbiAgICAgIC8vICAgY29uc29sZS50cmFjZShgJWMke21ldGFTdHJpbmd9YCwgYGNvbG9yOiR7Y29sb3J9YCwgbWVzc2FnZSwgLi4uYWRkaXRpb25hbCk7XG4gICAgICAvLyAgIGJyZWFrO1xuXG4gICAgICAvLyAgRGlzYWJsaW5nIGNvbnNvbGUuZGVidWcsIGJlY2F1c2UgSGFzIHRoaXMgaGlkZGVuIGJ5IGRlZmF1bHQuXG4gICAgICAvLyBjYXNlIE5neExvZ2dlckxldmVsLkRFQlVHOlxuICAgICAgLy8gICBjb25zb2xlLmRlYnVnKGAlYyR7bWV0YVN0cmluZ31gLCBgY29sb3I6JHtjb2xvcn1gLCBtZXNzYWdlLCAuLi5hZGRpdGlvbmFsKTtcbiAgICAgIC8vICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjb25zb2xlLmxvZyhgJWMke21ldGFTdHJpbmd9YCwgYGNvbG9yOiR7Y29sb3J9YCwgbWVzc2FnZSwgLi4uYWRkaXRpb25hbCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfbG9nKGxldmVsOiBOZ3hMb2dnZXJMZXZlbCwgbWVzc2FnZSwgYWRkaXRpb25hbDogYW55W10gPSBbXSwgbG9nT25TZXJ2ZXI6IGJvb2xlYW4gPSB0cnVlKTogdm9pZCB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWcuZ2V0Q29uZmlnKCk7XG4gICAgY29uc3QgaXNMb2cyU2VydmVyID0gbG9nT25TZXJ2ZXIgJiYgY29uZmlnLnNlcnZlckxvZ2dpbmdVcmwgJiYgbGV2ZWwgPj0gY29uZmlnLnNlcnZlckxvZ0xldmVsO1xuICAgIGNvbnN0IGlzTG9nTGV2ZWxFbmFibGVkID0gbGV2ZWwgPj0gY29uZmlnLmxldmVsO1xuXG4gICAgaWYgKCEobWVzc2FnZSAmJiAoaXNMb2cyU2VydmVyIHx8IGlzTG9nTGV2ZWxFbmFibGVkKSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBsb2dMZXZlbFN0cmluZyA9IExldmVsc1tsZXZlbF07XG5cbiAgICBtZXNzYWdlID0gTkdYTG9nZ2VyVXRpbHMucHJlcGFyZU1lc3NhZ2UobWVzc2FnZSk7XG5cbiAgICAvLyBvbmx5IHVzZSB2YWxpZGF0ZWQgcGFyYW1ldGVycyBmb3IgSFRUUCByZXF1ZXN0c1xuICAgIGNvbnN0IHZhbGlkYXRlZEFkZGl0aW9uYWxQYXJhbWV0ZXJzID0gTkdYTG9nZ2VyVXRpbHMucHJlcGFyZUFkZGl0aW9uYWxQYXJhbWV0ZXJzKGFkZGl0aW9uYWwpO1xuXG4gICAgY29uc3QgdGltZXN0YW1wID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuXG4gICAgLy8gY29uc3QgY2FsbGVyRGV0YWlscyA9IE5HWExvZ2dlclV0aWxzLmdldENhbGxlckRldGFpbHMoKTtcbiAgICB0aGlzLm1hcHBlclNlcnZpY2UuZ2V0Q2FsbGVyRGV0YWlscyhjb25maWcuZW5hYmxlU291cmNlTWFwcykuc3Vic2NyaWJlKChjYWxsZXJEZXRhaWxzOiBMb2dQb3NpdGlvbikgPT4ge1xuICAgICAgY29uc3QgbG9nT2JqZWN0OiBOR1hMb2dJbnRlcmZhY2UgPSB7XG4gICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgIGFkZGl0aW9uYWw6IHZhbGlkYXRlZEFkZGl0aW9uYWxQYXJhbWV0ZXJzLFxuICAgICAgICBsZXZlbDogbGV2ZWwsXG4gICAgICAgIHRpbWVzdGFtcDogdGltZXN0YW1wLFxuICAgICAgICBmaWxlTmFtZTogY2FsbGVyRGV0YWlscy5maWxlTmFtZSxcbiAgICAgICAgbGluZU51bWJlcjogY2FsbGVyRGV0YWlscy5saW5lTnVtYmVyLnRvU3RyaW5nKClcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLl9sb2dnZXJNb25pdG9yICYmIGlzTG9nTGV2ZWxFbmFibGVkKSB7XG4gICAgICAgIHRoaXMuX2xvZ2dlck1vbml0b3Iub25Mb2cobG9nT2JqZWN0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzTG9nMlNlcnZlcikge1xuICAgICAgICAvLyBtYWtlIHN1cmUgdGhlIHN0YWNrIGdldHMgc2VudCB0byB0aGUgc2VydmVyXG4gICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlIGluc3RhbmNlb2YgRXJyb3IgPyBtZXNzYWdlLnN0YWNrIDogbWVzc2FnZTtcbiAgICAgICAgbG9nT2JqZWN0Lm1lc3NhZ2UgPSBtZXNzYWdlO1xuXG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLl9jdXN0b21IdHRwSGVhZGVycyB8fCBuZXcgSHR0cEhlYWRlcnMoKTtcbiAgICAgICAgaGVhZGVycy5zZXQoJ0NvbnRlbnQtVHlwZScsICdhcHBsaWNhdGlvbi9qc29uJyk7XG5cbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzLFxuICAgICAgICAgIHBhcmFtczogdGhpcy5fY3VzdG9tUGFyYW1zIHx8IG5ldyBIdHRwUGFyYW1zKCksXG4gICAgICAgICAgcmVzcG9uc2VUeXBlOiBjb25maWcuaHR0cFJlc3BvbnNlVHlwZSB8fCAnanNvbicsXG4gICAgICAgICAgd2l0aENyZWRlbnRpYWxzOiB0aGlzLl93aXRoQ3JlZGVudGlhbHNcbiAgICAgICAgfTtcbiAgICAgICAgLy8gQWxsb3cgbG9nZ2luZyBvbiBzZXJ2ZXIgZXZlbiBpZiBjbGllbnQgbG9nIGxldmVsIGlzIG9mZlxuICAgICAgICB0aGlzLmh0dHBTZXJ2aWNlLmxvZ09uU2VydmVyKGNvbmZpZy5zZXJ2ZXJMb2dnaW5nVXJsLCBsb2dPYmplY3QsIG9wdGlvbnMpLnN1YnNjcmliZSgocmVzOiBhbnkpID0+IHtcbiAgICAgICAgICAgIC8vIEkgZG9uJ3QgdGhpbmsgd2Ugc2hvdWxkIGRvIGFueXRoaW5nIG9uIHN1Y2Nlc3NcbiAgICAgICAgICB9LFxuICAgICAgICAgIChlcnJvcjogSHR0cEVycm9yUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2xvZyhOZ3hMb2dnZXJMZXZlbC5FUlJPUiwgYEZBSUxFRCBUTyBMT0cgT04gU0VSVkVSOiAke21lc3NhZ2V9YCwgW2Vycm9yXSwgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgIH1cblxuXG4gICAgICAvLyBpZiBubyBtZXNzYWdlIG9yIHRoZSBsb2cgbGV2ZWwgaXMgbGVzcyB0aGFuIHRoZSBlbnZpcm9uXG4gICAgICBpZiAoaXNMb2dMZXZlbEVuYWJsZWQgJiYgIWNvbmZpZy5kaXNhYmxlQ29uc29sZUxvZ2dpbmcpIHtcbiAgICAgICAgY29uc3QgbWV0YVN0cmluZyA9IE5HWExvZ2dlclV0aWxzLnByZXBhcmVNZXRhU3RyaW5nKHRpbWVzdGFtcCwgbG9nTGV2ZWxTdHJpbmcsXG4gICAgICAgICAgY2FsbGVyRGV0YWlscy5maWxlTmFtZSwgY2FsbGVyRGV0YWlscy5saW5lTnVtYmVyLnRvU3RyaW5nKCkpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9sb2dGdW5jKGxldmVsLCBtZXRhU3RyaW5nLCBtZXNzYWdlLCBhZGRpdGlvbmFsKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuIl19