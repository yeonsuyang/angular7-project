(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/common'), require('@angular/core'), require('@angular/common/http'), require('rxjs/operators'), require('vlq'), require('rxjs')) :
    typeof define === 'function' && define.amd ? define('ngx-logger', ['exports', '@angular/common', '@angular/core', '@angular/common/http', 'rxjs/operators', 'vlq', 'rxjs'], factory) :
    (global = global || self, factory(global['ngx-logger'] = {}, global.ng.common, global.ng.core, global.ng.common.http, global.rxjs.operators, global.vlq, global.rxjs));
}(this, function (exports, common, core, http, operators, vlq, rxjs) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NGXLoggerHttpService = /** @class */ (function () {
        function NGXLoggerHttpService(httpBackend) {
            this.httpBackend = httpBackend;
        }
        /**
         * @param {?} url
         * @param {?} log
         * @param {?} options
         * @return {?}
         */
        NGXLoggerHttpService.prototype.logOnServer = /**
         * @param {?} url
         * @param {?} log
         * @param {?} options
         * @return {?}
         */
        function (url, log, options) {
            // HttpBackend skips all HttpInterceptors
            // They may log errors using this service causing circular calls
            /** @type {?} */
            var req = new http.HttpRequest('POST', url, log, options || {});
            return this.httpBackend.handle(req).pipe(operators.filter((/**
             * @param {?} e
             * @return {?}
             */
            function (e) { return e instanceof http.HttpResponse; })), operators.map((/**
             * @param {?} httpResponse
             * @return {?}
             */
            function (httpResponse) { return httpResponse.body; })));
        };
        NGXLoggerHttpService.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        NGXLoggerHttpService.ctorParameters = function () { return [
            { type: http.HttpBackend }
        ]; };
        return NGXLoggerHttpService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @enum {number} */
    var NgxLoggerLevel = {
        TRACE: 0,
        DEBUG: 1,
        INFO: 2,
        LOG: 3,
        WARN: 4,
        ERROR: 5,
        FATAL: 6,
        OFF: 7,
    };
    NgxLoggerLevel[NgxLoggerLevel.TRACE] = 'TRACE';
    NgxLoggerLevel[NgxLoggerLevel.DEBUG] = 'DEBUG';
    NgxLoggerLevel[NgxLoggerLevel.INFO] = 'INFO';
    NgxLoggerLevel[NgxLoggerLevel.LOG] = 'LOG';
    NgxLoggerLevel[NgxLoggerLevel.WARN] = 'WARN';
    NgxLoggerLevel[NgxLoggerLevel.ERROR] = 'ERROR';
    NgxLoggerLevel[NgxLoggerLevel.FATAL] = 'FATAL';
    NgxLoggerLevel[NgxLoggerLevel.OFF] = 'OFF';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var LoggerConfig = /** @class */ (function () {
        function LoggerConfig() {
        }
        return LoggerConfig;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NGXLoggerConfigEngine = /** @class */ (function () {
        function NGXLoggerConfigEngine(config) {
            this.config = config;
            this._config = config;
        }
        /**
         * @param {?} config
         * @return {?}
         */
        NGXLoggerConfigEngine.prototype.updateConfig = /**
         * @param {?} config
         * @return {?}
         */
        function (config) {
            this._config = this._clone(config);
        };
        /**
         * @return {?}
         */
        NGXLoggerConfigEngine.prototype.getConfig = /**
         * @return {?}
         */
        function () {
            return this._clone(this._config);
        };
        // TODO: add tests around cloning the config. updating an object passed into the config (or retrieving from the config)
        // should not update the active config, this is a shallow clone. If our config ever becomes hierarchical we must make
        // this a deep clone
        // TODO: add tests around cloning the config. updating an object passed into the config (or retrieving from the config)
        // should not update the active config, this is a shallow clone. If our config ever becomes hierarchical we must make
        // this a deep clone
        /**
         * @private
         * @param {?} object
         * @return {?}
         */
        NGXLoggerConfigEngine.prototype._clone = 
        // TODO: add tests around cloning the config. updating an object passed into the config (or retrieving from the config)
        // should not update the active config, this is a shallow clone. If our config ever becomes hierarchical we must make
        // this a deep clone
        /**
         * @private
         * @param {?} object
         * @return {?}
         */
        function (object) {
            /** @type {?} */
            var cloneConfig = new LoggerConfig();
            Object.keys(object).forEach((/**
             * @param {?} key
             * @return {?}
             */
            function (key) {
                cloneConfig[key] = object[key];
            }));
            return cloneConfig;
        };
        return NGXLoggerConfigEngine;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NGXLoggerUtils = /** @class */ (function () {
        function NGXLoggerUtils() {
        }
        /**
         * @param {?} timestamp
         * @param {?} logLevel
         * @param {?} fileName
         * @param {?} lineNumber
         * @return {?}
         */
        NGXLoggerUtils.prepareMetaString = /**
         * @param {?} timestamp
         * @param {?} logLevel
         * @param {?} fileName
         * @param {?} lineNumber
         * @return {?}
         */
        function (timestamp, logLevel, fileName, lineNumber) {
            /** @type {?} */
            var fileDetails = fileName ? " [" + fileName + ":" + lineNumber + "]" : '';
            return timestamp + " " + logLevel + fileDetails;
        };
        /**
         * @param {?} level
         * @return {?}
         */
        NGXLoggerUtils.getColor = /**
         * @param {?} level
         * @return {?}
         */
        function (level) {
            switch (level) {
                case NgxLoggerLevel.TRACE:
                    return 'blue';
                case NgxLoggerLevel.DEBUG:
                    return 'teal';
                case NgxLoggerLevel.INFO:
                case NgxLoggerLevel.LOG:
                    return 'gray';
                case NgxLoggerLevel.WARN:
                case NgxLoggerLevel.ERROR:
                case NgxLoggerLevel.FATAL:
                    return 'red';
                case NgxLoggerLevel.OFF:
                default:
                    return;
            }
        };
        /**
         *  This allows us to see who called the logger
         */
        /**
         *  This allows us to see who called the logger
         * @return {?}
         */
        NGXLoggerUtils.getCallerDetails = /**
         *  This allows us to see who called the logger
         * @return {?}
         */
        function () {
            /** @type {?} */
            var err = (new Error(''));
            try {
                // this should produce the line which NGX Logger was called
                /** @type {?} */
                var callerLine = err.stack.split('\n')[4].split('/');
                // returns the file:lineNumber
                /** @type {?} */
                var fileLineNumber = callerLine[callerLine.length - 1].replace(/[)]/g, '').split(':');
                return {
                    fileName: fileLineNumber[0],
                    lineNumber: fileLineNumber[1]
                };
            }
            catch (e) {
                return {
                    fileName: null,
                    lineNumber: null
                };
            }
        };
        /**
         * @param {?} message
         * @return {?}
         */
        NGXLoggerUtils.prepareMessage = /**
         * @param {?} message
         * @return {?}
         */
        function (message) {
            try {
                if (typeof message !== 'string' && !(message instanceof Error)) {
                    message = JSON.stringify(message, null, 2);
                }
            }
            catch (e) {
                // additional = [message, ...additional];
                message = 'The provided "message" value could not be parsed with JSON.stringify().';
            }
            return message;
        };
        /**
         * @param {?} additional
         * @return {?}
         */
        NGXLoggerUtils.prepareAdditionalParameters = /**
         * @param {?} additional
         * @return {?}
         */
        function (additional) {
            if (additional === null || additional === undefined) {
                return null;
            }
            return additional.map((/**
             * @param {?} next
             * @param {?} idx
             * @return {?}
             */
            function (next, idx) {
                try {
                    // We just want to make sure the JSON can be parsed, we do not want to actually change the type
                    if (typeof next === 'object') {
                        JSON.stringify(next);
                    }
                    return next;
                }
                catch (e) {
                    return "The additional[" + idx + "] value could not be parsed using JSON.stringify().";
                }
            }));
        };
        return NGXLoggerUtils;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var LogPosition = /** @class */ (function () {
        function LogPosition(fileName, lineNumber, columnNumber) {
            this.fileName = fileName;
            this.lineNumber = lineNumber;
            this.columnNumber = columnNumber;
        }
        /**
         * @return {?}
         */
        LogPosition.prototype.toString = /**
         * @return {?}
         */
        function () {
            return this.fileName + ':' + this.lineNumber + ':' + this.columnNumber;
        };
        return LogPosition;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NGXMapperService = /** @class */ (function () {
        function NGXMapperService(httpBackend) {
            this.httpBackend = httpBackend;
            // used to cache source maps
            this.cache = {};
            this.errorCache = {};
        }
        /*
        Static Functions
       */
        /*
          Static Functions
         */
        /**
         * @private
         * @return {?}
         */
        NGXMapperService.getStackLine = /*
          Static Functions
         */
        /**
         * @private
         * @return {?}
         */
        function () {
            /** @type {?} */
            var error = new Error();
            try {
                // noinspection ExceptionCaughtLocallyJS
                throw error;
            }
            catch (e) {
                try {
                    return error.stack.split('\n')[5];
                }
                catch (e) {
                    return null;
                }
            }
        };
        /**
         * @private
         * @param {?} stackLine
         * @return {?}
         */
        NGXMapperService.getPosition = /**
         * @private
         * @param {?} stackLine
         * @return {?}
         */
        function (stackLine) {
            // strip base path, then parse filename, line, and column
            /** @type {?} */
            var position = stackLine.substring(stackLine.lastIndexOf('\/') + 1, stackLine.indexOf(')'));
            /** @type {?} */
            var dataArray = position.split(':');
            if (dataArray.length === 3) {
                return new LogPosition(dataArray[0], +dataArray[1], +dataArray[2]);
            }
            return new LogPosition('unknown', 0, 0);
        };
        /**
         * @private
         * @param {?} stackLine
         * @return {?}
         */
        NGXMapperService.getTranspileLocation = /**
         * @private
         * @param {?} stackLine
         * @return {?}
         */
        function (stackLine) {
            return stackLine.substring(stackLine.indexOf('(') + 1, stackLine.indexOf(')'));
        };
        /**
         * @private
         * @param {?} stackLine
         * @return {?}
         */
        NGXMapperService.getMapFilePath = /**
         * @private
         * @param {?} stackLine
         * @return {?}
         */
        function (stackLine) {
            /** @type {?} */
            var file = NGXMapperService.getTranspileLocation(stackLine);
            /** @type {?} */
            var mapFullPath = file.substring(0, file.lastIndexOf(':'));
            return mapFullPath.substring(0, mapFullPath.lastIndexOf(':')) + '.map';
        };
        /**
         * @private
         * @param {?} sourceMap
         * @param {?} position
         * @return {?}
         */
        NGXMapperService.getMapping = /**
         * @private
         * @param {?} sourceMap
         * @param {?} position
         * @return {?}
         */
        function (sourceMap, position) {
            // => ';' indicates end of a line
            // => ',' separates mappings in a line
            // decoded mapping => [ generatedCodeColumn, sourceFileIndex, sourceCodeLine, sourceCodeColumn, nameIndex ]
            /** @type {?} */
            var sourceFileIndex = 0;
            /** @type {?} */
            var // second field
            sourceCodeLine = 0;
            /** @type {?} */
            var // third field
            sourceCodeColumn = 0;
            // fourth field
            /** @type {?} */
            var lines = sourceMap.mappings.split(';');
            for (var lineIndex = 0; lineIndex < lines.length; lineIndex++) {
                // reset column position to 0 after each line
                /** @type {?} */
                var generatedCodeColumn = 0;
                // decode sections in line
                /** @type {?} */
                var columns = lines[lineIndex].split(',');
                for (var columnIndex = 0; columnIndex < columns.length; columnIndex++) {
                    /** @type {?} */
                    var decodedSection = vlq.decode(columns[columnIndex]);
                    if (decodedSection.length >= 4) {
                        // update relative positions
                        generatedCodeColumn += decodedSection[0];
                        sourceFileIndex += decodedSection[1];
                        sourceCodeLine += decodedSection[2];
                        sourceCodeColumn += decodedSection[3];
                    }
                    // check if matching map
                    if (lineIndex === position.lineNumber) {
                        if (generatedCodeColumn === position.columnNumber) {
                            // matching column and line found
                            return new LogPosition(sourceMap.sources[sourceFileIndex], sourceCodeLine, sourceCodeColumn);
                        }
                        else if (columnIndex + 1 === columns.length) {
                            // matching column not found, but line is correct
                            return new LogPosition(sourceMap.sources[sourceFileIndex], sourceCodeLine, 0);
                        }
                    }
                }
            }
            // failed if reached
            return new LogPosition('unknown', 0, 0);
        };
        /**
         * does the http get request to get the source map
         * @param sourceMapLocation
         * @param distPosition
         */
        /**
         * does the http get request to get the source map
         * @private
         * @param {?} sourceMapLocation
         * @param {?} distPosition
         * @return {?}
         */
        NGXMapperService.prototype._getSourceMap = /**
         * does the http get request to get the source map
         * @private
         * @param {?} sourceMapLocation
         * @param {?} distPosition
         * @return {?}
         */
        function (sourceMapLocation, distPosition) {
            var _this = this;
            /** @type {?} */
            var req = new http.HttpRequest('GET', sourceMapLocation);
            return this.httpBackend.handle(req).pipe(operators.filter((/**
             * @param {?} e
             * @return {?}
             */
            function (e) { return (e instanceof http.HttpResponse); })), operators.map((/**
             * @param {?} httpResponse
             * @return {?}
             */
            function (httpResponse) { return httpResponse.body; })), operators.map((/**
             * @param {?} sourceMap
             * @return {?}
             */
            function (sourceMap) {
                // store file in cache if not already stored
                if (!_this.cache.hasOwnProperty(sourceMapLocation)) {
                    _this.cache[sourceMapLocation] = sourceMap;
                }
                // map generated position to source position
                return NGXMapperService.getMapping(sourceMap, distPosition);
            })), operators.retry(3), 
            // if there is an error getting the source, map fall back to the filename and line number of
            operators.catchError((/**
             * @return {?}
             */
            function () {
                _this.errorCache[sourceMapLocation] = true;
                return rxjs.of(distPosition);
            })));
        };
        /**
         * Returns the LogPosition for the current log
         * If sourceMaps are enabled, it attemps to get the source map from the server, and use that to parse the file name
         * and number of the call
         * @param sourceMapsEnabled
         */
        /**
         * Returns the LogPosition for the current log
         * If sourceMaps are enabled, it attemps to get the source map from the server, and use that to parse the file name
         * and number of the call
         * @param {?} sourceMapsEnabled
         * @return {?}
         */
        NGXMapperService.prototype.getCallerDetails = /**
         * Returns the LogPosition for the current log
         * If sourceMaps are enabled, it attemps to get the source map from the server, and use that to parse the file name
         * and number of the call
         * @param {?} sourceMapsEnabled
         * @return {?}
         */
        function (sourceMapsEnabled) {
            // parse generated file mapping from stack trace
            var _this = this;
            // parse generated file mapping from stack trace
            /** @type {?} */
            var stackLine = NGXMapperService.getStackLine();
            // if we were not able to parse the stackLine, just return an empty Log Position
            if (!stackLine) {
                return rxjs.of(new LogPosition('', 0, 0));
            }
            return rxjs.of([
                NGXMapperService.getPosition(stackLine),
                NGXMapperService.getMapFilePath(stackLine)
            ]).pipe(operators.switchMap((/**
             * @param {?} __0
             * @return {?}
             */
            function (_a) {
                var _b = __read(_a, 2), distPosition = _b[0], sourceMapLocation = _b[1];
                // if source maps are not enabled, or if we've previously tried to get the source maps, but they failed,
                // then just use the position of the JS instead of the source
                if (!sourceMapsEnabled || _this.errorCache.hasOwnProperty(sourceMapLocation)) {
                    return rxjs.of(distPosition);
                }
                // check if we have map has already, otherwise request from server
                if (_this.cache.hasOwnProperty(sourceMapLocation)) {
                    return rxjs.of(NGXMapperService.getMapping(_this.cache[sourceMapLocation], distPosition));
                }
                // finally try to get the source map and return the position
                return _this._getSourceMap(sourceMapLocation, distPosition);
            })));
        };
        NGXMapperService.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        NGXMapperService.ctorParameters = function () { return [
            { type: http.HttpBackend }
        ]; };
        return NGXMapperService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var Levels = [
        'TRACE',
        'DEBUG',
        'INFO',
        'LOG',
        'WARN',
        'ERROR',
        'FATAL',
        'OFF'
    ];
    var NGXLogger = /** @class */ (function () {
        function NGXLogger(mapperService, httpService, loggerConfig) {
            this.mapperService = mapperService;
            this.httpService = httpService;
            this._withCredentials = false;
            this._isIE = navigator && navigator.userAgent &&
                !!(navigator.userAgent.indexOf('MSIE') !== -1 || navigator.userAgent.match(/Trident\//) || navigator.userAgent.match(/Edge\//));
            // each instance of the logger should have their own config engine
            this.config = new NGXLoggerConfigEngine(loggerConfig);
            this._logFunc = this._isIE ? this._logIE.bind(this) : this._logModern.bind(this);
        }
        /**
         * @param {?} message
         * @param {...?} additional
         * @return {?}
         */
        NGXLogger.prototype.trace = /**
         * @param {?} message
         * @param {...?} additional
         * @return {?}
         */
        function (message) {
            var additional = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                additional[_i - 1] = arguments[_i];
            }
            this._log(NgxLoggerLevel.TRACE, message, additional);
        };
        /**
         * @param {?} message
         * @param {...?} additional
         * @return {?}
         */
        NGXLogger.prototype.debug = /**
         * @param {?} message
         * @param {...?} additional
         * @return {?}
         */
        function (message) {
            var additional = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                additional[_i - 1] = arguments[_i];
            }
            this._log(NgxLoggerLevel.DEBUG, message, additional);
        };
        /**
         * @param {?} message
         * @param {...?} additional
         * @return {?}
         */
        NGXLogger.prototype.info = /**
         * @param {?} message
         * @param {...?} additional
         * @return {?}
         */
        function (message) {
            var additional = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                additional[_i - 1] = arguments[_i];
            }
            this._log(NgxLoggerLevel.INFO, message, additional);
        };
        /**
         * @param {?} message
         * @param {...?} additional
         * @return {?}
         */
        NGXLogger.prototype.log = /**
         * @param {?} message
         * @param {...?} additional
         * @return {?}
         */
        function (message) {
            var additional = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                additional[_i - 1] = arguments[_i];
            }
            this._log(NgxLoggerLevel.LOG, message, additional);
        };
        /**
         * @param {?} message
         * @param {...?} additional
         * @return {?}
         */
        NGXLogger.prototype.warn = /**
         * @param {?} message
         * @param {...?} additional
         * @return {?}
         */
        function (message) {
            var additional = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                additional[_i - 1] = arguments[_i];
            }
            this._log(NgxLoggerLevel.WARN, message, additional);
        };
        /**
         * @param {?} message
         * @param {...?} additional
         * @return {?}
         */
        NGXLogger.prototype.error = /**
         * @param {?} message
         * @param {...?} additional
         * @return {?}
         */
        function (message) {
            var additional = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                additional[_i - 1] = arguments[_i];
            }
            this._log(NgxLoggerLevel.ERROR, message, additional);
        };
        /**
         * @param {?} message
         * @param {...?} additional
         * @return {?}
         */
        NGXLogger.prototype.fatal = /**
         * @param {?} message
         * @param {...?} additional
         * @return {?}
         */
        function (message) {
            var additional = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                additional[_i - 1] = arguments[_i];
            }
            this._log(NgxLoggerLevel.FATAL, message, additional);
        };
        /**
         * @param {?} headers
         * @return {?}
         */
        NGXLogger.prototype.setCustomHttpHeaders = /**
         * @param {?} headers
         * @return {?}
         */
        function (headers) {
            this._customHttpHeaders = headers;
        };
        /**
         * @param {?} params
         * @return {?}
         */
        NGXLogger.prototype.setCustomParams = /**
         * @param {?} params
         * @return {?}
         */
        function (params) {
            this._customParams = params;
        };
        /**
         * @param {?} withCredentials
         * @return {?}
         */
        NGXLogger.prototype.setWithCredentialsOptionValue = /**
         * @param {?} withCredentials
         * @return {?}
         */
        function (withCredentials) {
            this._withCredentials = withCredentials;
        };
        /**
         * @param {?} monitor
         * @return {?}
         */
        NGXLogger.prototype.registerMonitor = /**
         * @param {?} monitor
         * @return {?}
         */
        function (monitor) {
            this._loggerMonitor = monitor;
        };
        /**
         * @param {?} config
         * @return {?}
         */
        NGXLogger.prototype.updateConfig = /**
         * @param {?} config
         * @return {?}
         */
        function (config) {
            this.config.updateConfig(config);
        };
        /**
         * @return {?}
         */
        NGXLogger.prototype.getConfigSnapshot = /**
         * @return {?}
         */
        function () {
            return this.config.getConfig();
        };
        /**
         * @private
         * @param {?} level
         * @param {?} metaString
         * @param {?} message
         * @param {?} additional
         * @return {?}
         */
        NGXLogger.prototype._logIE = /**
         * @private
         * @param {?} level
         * @param {?} metaString
         * @param {?} message
         * @param {?} additional
         * @return {?}
         */
        function (level, metaString, message, additional) {
            // Coloring doesn't work in IE
            // make sure additional isn't null or undefined so that ...additional doesn't error
            additional = additional || [];
            switch (level) {
                case NgxLoggerLevel.WARN:
                    console.warn.apply(console, __spread([metaString + " ", message], additional));
                    break;
                case NgxLoggerLevel.ERROR:
                case NgxLoggerLevel.FATAL:
                    console.error.apply(console, __spread([metaString + " ", message], additional));
                    break;
                case NgxLoggerLevel.INFO:
                    console.info.apply(console, __spread([metaString + " ", message], additional));
                    break;
                default:
                    console.log.apply(console, __spread([metaString + " ", message], additional));
            }
        };
        /**
         * @private
         * @param {?} level
         * @param {?} metaString
         * @param {?} message
         * @param {?} additional
         * @return {?}
         */
        NGXLogger.prototype._logModern = /**
         * @private
         * @param {?} level
         * @param {?} metaString
         * @param {?} message
         * @param {?} additional
         * @return {?}
         */
        function (level, metaString, message, additional) {
            /** @type {?} */
            var color = NGXLoggerUtils.getColor(level);
            // make sure additional isn't null or undefined so that ...additional doesn't error
            additional = additional || [];
            switch (level) {
                case NgxLoggerLevel.WARN:
                    console.warn.apply(console, __spread(["%c" + metaString, "color:" + color, message], additional));
                    break;
                case NgxLoggerLevel.ERROR:
                case NgxLoggerLevel.FATAL:
                    console.error.apply(console, __spread(["%c" + metaString, "color:" + color, message], additional));
                    break;
                case NgxLoggerLevel.INFO:
                    console.info.apply(console, __spread(["%c" + metaString, "color:" + color, message], additional));
                    break;
                //  Disabling console.trace since the stack trace is not helpful. it is showing the stack trace of
                // the console.trace statement
                // case NgxLoggerLevel.TRACE:
                //   console.trace(`%c${metaString}`, `color:${color}`, message, ...additional);
                //   break;
                //  Disabling console.debug, because Has this hidden by default.
                // case NgxLoggerLevel.DEBUG:
                //   console.debug(`%c${metaString}`, `color:${color}`, message, ...additional);
                //   break;
                default:
                    console.log.apply(console, __spread(["%c" + metaString, "color:" + color, message], additional));
            }
        };
        /**
         * @private
         * @param {?} level
         * @param {?} message
         * @param {?=} additional
         * @param {?=} logOnServer
         * @return {?}
         */
        NGXLogger.prototype._log = /**
         * @private
         * @param {?} level
         * @param {?} message
         * @param {?=} additional
         * @param {?=} logOnServer
         * @return {?}
         */
        function (level, message, additional, logOnServer) {
            var _this = this;
            if (additional === void 0) { additional = []; }
            if (logOnServer === void 0) { logOnServer = true; }
            /** @type {?} */
            var config = this.config.getConfig();
            /** @type {?} */
            var isLog2Server = logOnServer && config.serverLoggingUrl && level >= config.serverLogLevel;
            /** @type {?} */
            var isLogLevelEnabled = level >= config.level;
            if (!(message && (isLog2Server || isLogLevelEnabled))) {
                return;
            }
            /** @type {?} */
            var logLevelString = Levels[level];
            message = NGXLoggerUtils.prepareMessage(message);
            // only use validated parameters for HTTP requests
            /** @type {?} */
            var validatedAdditionalParameters = NGXLoggerUtils.prepareAdditionalParameters(additional);
            /** @type {?} */
            var timestamp = new Date().toISOString();
            // const callerDetails = NGXLoggerUtils.getCallerDetails();
            this.mapperService.getCallerDetails(config.enableSourceMaps).subscribe((/**
             * @param {?} callerDetails
             * @return {?}
             */
            function (callerDetails) {
                /** @type {?} */
                var logObject = {
                    message: message,
                    additional: validatedAdditionalParameters,
                    level: level,
                    timestamp: timestamp,
                    fileName: callerDetails.fileName,
                    lineNumber: callerDetails.lineNumber.toString()
                };
                if (_this._loggerMonitor && isLogLevelEnabled) {
                    _this._loggerMonitor.onLog(logObject);
                }
                if (isLog2Server) {
                    // make sure the stack gets sent to the server
                    message = message instanceof Error ? message.stack : message;
                    logObject.message = message;
                    /** @type {?} */
                    var headers = _this._customHttpHeaders || new http.HttpHeaders();
                    headers.set('Content-Type', 'application/json');
                    /** @type {?} */
                    var options = {
                        headers: headers,
                        params: _this._customParams || new http.HttpParams(),
                        responseType: config.httpResponseType || 'json',
                        withCredentials: _this._withCredentials
                    };
                    // Allow logging on server even if client log level is off
                    _this.httpService.logOnServer(config.serverLoggingUrl, logObject, options).subscribe((/**
                     * @param {?} res
                     * @return {?}
                     */
                    function (res) {
                        // I don't think we should do anything on success
                    }), (/**
                     * @param {?} error
                     * @return {?}
                     */
                    function (error) {
                        _this._log(NgxLoggerLevel.ERROR, "FAILED TO LOG ON SERVER: " + message, [error], false);
                    }));
                }
                // if no message or the log level is less than the environ
                if (isLogLevelEnabled && !config.disableConsoleLogging) {
                    /** @type {?} */
                    var metaString = NGXLoggerUtils.prepareMetaString(timestamp, logLevelString, callerDetails.fileName, callerDetails.lineNumber.toString());
                    return _this._logFunc(level, metaString, message, additional);
                }
            }));
        };
        NGXLogger.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        NGXLogger.ctorParameters = function () { return [
            { type: NGXMapperService },
            { type: NGXLoggerHttpService },
            { type: LoggerConfig }
        ]; };
        return NGXLogger;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * CustomNGXLoggerService is designed to allow users to get a new instance of a logger
     */
    var CustomNGXLoggerService = /** @class */ (function () {
        function CustomNGXLoggerService(mapperService, httpService) {
            this.mapperService = mapperService;
            this.httpService = httpService;
        }
        /**
         * @param {?} config
         * @param {?=} httpService
         * @param {?=} logMonitor
         * @param {?=} mapperService
         * @return {?}
         */
        CustomNGXLoggerService.prototype.create = /**
         * @param {?} config
         * @param {?=} httpService
         * @param {?=} logMonitor
         * @param {?=} mapperService
         * @return {?}
         */
        function (config, httpService, logMonitor, mapperService) {
            // you can inject your own httpService or use the default,
            /** @type {?} */
            var logger = new NGXLogger(mapperService || this.mapperService, httpService || this.httpService, config);
            if (logMonitor) {
                logger.registerMonitor(logMonitor);
            }
            return logger;
        };
        CustomNGXLoggerService.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        CustomNGXLoggerService.ctorParameters = function () { return [
            { type: NGXMapperService },
            { type: NGXLoggerHttpService }
        ]; };
        return CustomNGXLoggerService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var LoggerModule = /** @class */ (function () {
        function LoggerModule() {
        }
        /**
         * @param {?} config
         * @return {?}
         */
        LoggerModule.forRoot = /**
         * @param {?} config
         * @return {?}
         */
        function (config) {
            return {
                ngModule: LoggerModule,
                providers: [
                    { provide: LoggerConfig, useValue: config || {} },
                    NGXLogger,
                    NGXLoggerHttpService,
                    CustomNGXLoggerService,
                    NGXMapperService
                ]
            };
        };
        /**
         * @return {?}
         */
        LoggerModule.forChild = /**
         * @return {?}
         */
        function () {
            return {
                ngModule: LoggerModule,
                providers: [
                    NGXLogger,
                    NGXLoggerHttpService,
                    CustomNGXLoggerService,
                    NGXMapperService
                ]
            };
        };
        LoggerModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule
                        ],
                        providers: [
                            NGXLogger,
                            NGXLoggerHttpService,
                            CustomNGXLoggerService,
                            NGXMapperService
                        ]
                    },] }
        ];
        return LoggerModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @abstract
     */
    var   /**
     * @abstract
     */
    NGXLoggerMonitor = /** @class */ (function () {
        function NGXLoggerMonitor() {
        }
        return NGXLoggerMonitor;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NGXLogInterface = /** @class */ (function () {
        function NGXLogInterface() {
        }
        return NGXLogInterface;
    }());

    exports.CustomNGXLoggerService = CustomNGXLoggerService;
    exports.Levels = Levels;
    exports.LoggerConfig = LoggerConfig;
    exports.LoggerModule = LoggerModule;
    exports.NGXLogInterface = NGXLogInterface;
    exports.NGXLogger = NGXLogger;
    exports.NGXLoggerHttpService = NGXLoggerHttpService;
    exports.NGXLoggerMonitor = NGXLoggerMonitor;
    exports.NGXLoggerUtils = NGXLoggerUtils;
    exports.NGXMapperService = NGXMapperService;
    exports.NgxLoggerLevel = NgxLoggerLevel;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=ngx-logger.umd.js.map
