/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Injectable } from '@angular/core';
import { HttpBackend, HttpRequest, HttpResponse } from '@angular/common/http';
import * as vlq from 'vlq';
import { of } from 'rxjs';
import { catchError, filter, map, retry, switchMap } from 'rxjs/operators';
import { LogPosition } from './types/log-position';
export class NGXMapperService {
    /**
     * @param {?} httpBackend
     */
    constructor(httpBackend) {
        this.httpBackend = httpBackend;
        // used to cache source maps
        this.cache = {};
        this.errorCache = {};
    }
    /*
      Static Functions
     */
    /**
     * @private
     * @return {?}
     */
    static getStackLine() {
        /** @type {?} */
        const error = new Error();
        try {
            // noinspection ExceptionCaughtLocallyJS
            throw error;
        }
        catch (e) {
            try {
                return error.stack.split('\n')[5];
            }
            catch (e) {
                return null;
            }
        }
    }
    /**
     * @private
     * @param {?} stackLine
     * @return {?}
     */
    static getPosition(stackLine) {
        // strip base path, then parse filename, line, and column
        /** @type {?} */
        const position = stackLine.substring(stackLine.lastIndexOf('\/') + 1, stackLine.indexOf(')'));
        /** @type {?} */
        const dataArray = position.split(':');
        if (dataArray.length === 3) {
            return new LogPosition(dataArray[0], +dataArray[1], +dataArray[2]);
        }
        return new LogPosition('unknown', 0, 0);
    }
    /**
     * @private
     * @param {?} stackLine
     * @return {?}
     */
    static getTranspileLocation(stackLine) {
        return stackLine.substring(stackLine.indexOf('(') + 1, stackLine.indexOf(')'));
    }
    /**
     * @private
     * @param {?} stackLine
     * @return {?}
     */
    static getMapFilePath(stackLine) {
        /** @type {?} */
        const file = NGXMapperService.getTranspileLocation(stackLine);
        /** @type {?} */
        const mapFullPath = file.substring(0, file.lastIndexOf(':'));
        return mapFullPath.substring(0, mapFullPath.lastIndexOf(':')) + '.map';
    }
    /**
     * @private
     * @param {?} sourceMap
     * @param {?} position
     * @return {?}
     */
    static getMapping(sourceMap, position) {
        // => ';' indicates end of a line
        // => ',' separates mappings in a line
        // decoded mapping => [ generatedCodeColumn, sourceFileIndex, sourceCodeLine, sourceCodeColumn, nameIndex ]
        /** @type {?} */
        let sourceFileIndex = 0;
        /** @type {?} */
        let // second field
        sourceCodeLine = 0;
        /** @type {?} */
        let // third field
        sourceCodeColumn = 0;
        // fourth field
        /** @type {?} */
        const lines = sourceMap.mappings.split(';');
        for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
            // reset column position to 0 after each line
            /** @type {?} */
            let generatedCodeColumn = 0;
            // decode sections in line
            /** @type {?} */
            const columns = lines[lineIndex].split(',');
            for (let columnIndex = 0; columnIndex < columns.length; columnIndex++) {
                /** @type {?} */
                const decodedSection = vlq.decode(columns[columnIndex]);
                if (decodedSection.length >= 4) {
                    // update relative positions
                    generatedCodeColumn += decodedSection[0];
                    sourceFileIndex += decodedSection[1];
                    sourceCodeLine += decodedSection[2];
                    sourceCodeColumn += decodedSection[3];
                }
                // check if matching map
                if (lineIndex === position.lineNumber) {
                    if (generatedCodeColumn === position.columnNumber) {
                        // matching column and line found
                        return new LogPosition(sourceMap.sources[sourceFileIndex], sourceCodeLine, sourceCodeColumn);
                    }
                    else if (columnIndex + 1 === columns.length) {
                        // matching column not found, but line is correct
                        return new LogPosition(sourceMap.sources[sourceFileIndex], sourceCodeLine, 0);
                    }
                }
            }
        }
        // failed if reached
        return new LogPosition('unknown', 0, 0);
    }
    /**
     * does the http get request to get the source map
     * @private
     * @param {?} sourceMapLocation
     * @param {?} distPosition
     * @return {?}
     */
    _getSourceMap(sourceMapLocation, distPosition) {
        /** @type {?} */
        const req = new HttpRequest('GET', sourceMapLocation);
        return this.httpBackend.handle(req).pipe(filter((/**
         * @param {?} e
         * @return {?}
         */
        e => (e instanceof HttpResponse))), map((/**
         * @param {?} httpResponse
         * @return {?}
         */
        (httpResponse) => httpResponse.body)), map((/**
         * @param {?} sourceMap
         * @return {?}
         */
        sourceMap => {
            // store file in cache if not already stored
            if (!this.cache.hasOwnProperty(sourceMapLocation)) {
                this.cache[sourceMapLocation] = sourceMap;
            }
            // map generated position to source position
            return NGXMapperService.getMapping(sourceMap, distPosition);
        })), retry(3), 
        // if there is an error getting the source, map fall back to the filename and line number of
        catchError((/**
         * @return {?}
         */
        () => {
            this.errorCache[sourceMapLocation] = true;
            return of(distPosition);
        })));
    }
    /**
     * Returns the LogPosition for the current log
     * If sourceMaps are enabled, it attemps to get the source map from the server, and use that to parse the file name
     * and number of the call
     * @param {?} sourceMapsEnabled
     * @return {?}
     */
    getCallerDetails(sourceMapsEnabled) {
        // parse generated file mapping from stack trace
        // parse generated file mapping from stack trace
        /** @type {?} */
        const stackLine = NGXMapperService.getStackLine();
        // if we were not able to parse the stackLine, just return an empty Log Position
        if (!stackLine) {
            return of(new LogPosition('', 0, 0));
        }
        return of([
            NGXMapperService.getPosition(stackLine),
            NGXMapperService.getMapFilePath(stackLine)
        ]).pipe(switchMap((/**
         * @param {?} __0
         * @return {?}
         */
        ([distPosition, sourceMapLocation]) => {
            // if source maps are not enabled, or if we've previously tried to get the source maps, but they failed,
            // then just use the position of the JS instead of the source
            if (!sourceMapsEnabled || this.errorCache.hasOwnProperty(sourceMapLocation)) {
                return of(distPosition);
            }
            // check if we have map has already, otherwise request from server
            if (this.cache.hasOwnProperty(sourceMapLocation)) {
                return of(NGXMapperService.getMapping(this.cache[sourceMapLocation], distPosition));
            }
            // finally try to get the source map and return the position
            return this._getSourceMap(sourceMapLocation, distPosition);
        })));
    }
}
NGXMapperService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
NGXMapperService.ctorParameters = () => [
    { type: HttpBackend }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    NGXMapperService.prototype.cache;
    /**
     * @type {?}
     * @private
     */
    NGXMapperService.prototype.errorCache;
    /**
     * @type {?}
     * @private
     */
    NGXMapperService.prototype.httpBackend;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFwcGVyLnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9uZ3gtbG9nZ2VyLyIsInNvdXJjZXMiOlsibGliL21hcHBlci5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFDQSxPQUFPLEVBQUMsVUFBVSxFQUFDLE1BQU0sZUFBZSxDQUFDO0FBQ3pDLE9BQU8sRUFBQyxXQUFXLEVBQUUsV0FBVyxFQUFFLFlBQVksRUFBQyxNQUFNLHNCQUFzQixDQUFDO0FBQzVFLE9BQU8sS0FBSyxHQUFHLE1BQU0sS0FBSyxDQUFDO0FBQzNCLE9BQU8sRUFBYSxFQUFFLEVBQUMsTUFBTSxNQUFNLENBQUM7QUFDcEMsT0FBTyxFQUFDLFVBQVUsRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUMsTUFBTSxnQkFBZ0IsQ0FBQztBQUN6RSxPQUFPLEVBQUMsV0FBVyxFQUFDLE1BQU0sc0JBQXNCLENBQUM7QUFHakQsTUFBTSxPQUFPLGdCQUFnQjs7OztJQU0zQixZQUFvQixXQUF3QjtRQUF4QixnQkFBVyxHQUFYLFdBQVcsQ0FBYTs7UUFIcEMsVUFBSyxHQUFpQyxFQUFFLENBQUM7UUFDekMsZUFBVSxHQUErQixFQUFFLENBQUM7SUFHcEQsQ0FBQzs7Ozs7Ozs7SUFLTyxNQUFNLENBQUMsWUFBWTs7Y0FDbkIsS0FBSyxHQUFHLElBQUksS0FBSyxFQUFFO1FBRXpCLElBQUk7WUFDRix3Q0FBd0M7WUFDeEMsTUFBTSxLQUFLLENBQUM7U0FDYjtRQUFDLE9BQU8sQ0FBQyxFQUFFO1lBRVYsSUFBSTtnQkFDRixPQUFPLEtBQUssQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2FBQ25DO1lBQUMsT0FBTyxDQUFDLEVBQUU7Z0JBQ1YsT0FBTyxJQUFJLENBQUM7YUFDYjtTQUNGO0lBQ0gsQ0FBQzs7Ozs7O0lBRU8sTUFBTSxDQUFDLFdBQVcsQ0FBQyxTQUFpQjs7O2NBRXBDLFFB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WUFOSCxXQUFXOzs7Ozs7O0lBVWpCLGlDQUFpRDs7Ozs7SUFDakQsc0NBQW9EOzs7OztJQUV4Qyx1Q0FBZ0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1NvdXJjZU1hcH0gZnJvbSAnQGFuZ3VsYXIvY29tcGlsZXInO1xuaW1wb3J0IHtJbmplY3RhYmxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7SHR0cEJhY2tlbmQsIEh0dHBSZXF1ZXN0LCBIdHRwUmVzcG9uc2V9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbi9odHRwJztcbmltcG9ydCAqIGFzIHZscSBmcm9tICd2bHEnO1xuaW1wb3J0IHtPYnNlcnZhYmxlLCBvZn0gZnJvbSAncnhqcyc7XG5pbXBvcnQge2NhdGNoRXJyb3IsIGZpbHRlciwgbWFwLCByZXRyeSwgc3dpdGNoTWFwfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQge0xvZ1Bvc2l0aW9ufSBmcm9tICcuL3R5cGVzL2xvZy1wb3NpdGlvbic7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBOR1hNYXBwZXJTZXJ2aWNlIHtcblxuICAvLyB1c2VkIHRvIGNhY2hlIHNvdXJjZSBtYXBzXG4gIHByaXZhdGUgY2FjaGU6IHsgW2tleTogc3RyaW5nXTogU291cmNlTWFwIH0gPSB7fTtcbiAgcHJpdmF0ZSBlcnJvckNhY2hlOiB7IFtrZXk6IHN0cmluZ106IGJvb2xlYW4gfSA9IHt9O1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgaHR0cEJhY2tlbmQ6IEh0dHBCYWNrZW5kKSB7XG4gIH1cblxuICAvKlxuICBTdGF0aWMgRnVuY3Rpb25zXG4gKi9cbiAgcHJpdmF0ZSBzdGF0aWMgZ2V0U3RhY2tMaW5lKCk6IHN0cmluZyB7XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoKTtcblxuICAgIHRyeSB7XG4gICAgICAvLyBub2luc3BlY3Rpb24gRXhjZXB0aW9uQ2F1Z2h0TG9jYWxseUpTXG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9IGNhdGNoIChlKSB7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBlcnJvci5zdGFjay5zcGxpdCgnXFxuJylbNV07XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIGdldFBvc2l0aW9uKHN0YWNrTGluZTogc3RyaW5nKTogTG9nUG9zaXRpb24ge1xuICAgIC8vIHN0cmlwIGJhc2UgcGF0aCwgdGhlbiBwYXJzZSBmaWxlbmFtZSwgbGluZSwgYW5kIGNvbHVtblxuICAgIGNvbnN0IHBvc2l0aW9uID0gc3RhY2tMaW5lLnN1YnN0cmluZyhzdGFja0xpbmUubGFzdEluZGV4T2YoJ1xcLycpICsgMSwgc3RhY2tMaW5lLmluZGV4T2YoJyknKSk7XG4gICAgY29uc3QgZGF0YUFycmF5ID0gcG9zaXRpb24uc3BsaXQoJzonKTtcbiAgICBpZiAoZGF0YUFycmF5Lmxlbmd0aCA9PT0gMykge1xuICAgICAgcmV0dXJuIG5ldyBMb2dQb3NpdGlvbihkYXRhQXJyYXlbMF0sICtkYXRhQXJyYXlbMV0sICtkYXRhQXJyYXlbMl0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IExvZ1Bvc2l0aW9uKCd1bmtub3duJywgMCwgMCk7XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBnZXRUcmFuc3BpbGVMb2NhdGlvbihzdGFja0xpbmU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHN0YWNrTGluZS5zdWJzdHJpbmcoc3RhY2tMaW5lLmluZGV4T2YoJygnKSArIDEsIHN0YWNrTGluZS5pbmRleE9mKCcpJykpO1xuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgZ2V0TWFwRmlsZVBhdGgoc3RhY2tMaW5lOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGNvbnN0IGZpbGUgPSBOR1hNYXBwZXJTZXJ2aWNlLmdldFRyYW5zcGlsZUxvY2F0aW9uKHN0YWNrTGluZSk7XG4gICAgY29uc3QgbWFwRnVsbFBhdGggPSBmaWxlLnN1YnN0cmluZygwLCBmaWxlLmxhc3RJbmRleE9mKCc6JykpO1xuICAgIHJldHVybiBtYXBGdWxsUGF0aC5zdWJzdHJpbmcoMCwgbWFwRnVsbFBhdGgubGFzdEluZGV4T2YoJzonKSkgKyAnLm1hcCc7XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBnZXRNYXBwaW5nKHNvdXJjZU1hcDogU291cmNlTWFwLCBwb3NpdGlvbjogTG9nUG9zaXRpb24pOiBMb2dQb3NpdGlvbiB7XG4gICAgLy8gPT4gJzsnIGluZGljYXRlcyBlbmQgb2YgYSBsaW5lXG4gICAgLy8gPT4gJywnIHNlcGFyYXRlcyBtYXBwaW5ncyBpbiBhIGxpbmVcbiAgICAvLyBkZWNvZGVkIG1hcHBpbmcgPT4gWyBnZW5lcmF0ZWRDb2RlQ29sdW1uLCBzb3VyY2VGaWxlSW5kZXgsIHNvdXJjZUNvZGVMaW5lLCBzb3VyY2VDb2RlQ29sdW1uLCBuYW1lSW5kZXggXVxuICAgIGxldCBzb3VyY2VGaWxlSW5kZXggPSAwLCAgIC8vIHNlY29uZCBmaWVsZFxuICAgICAgc291cmNlQ29kZUxpbmUgPSAwLCAgICAvLyB0aGlyZCBmaWVsZFxuICAgICAgc291cmNlQ29kZUNvbHVtbiA9IDA7ICAvLyBmb3VydGggZmllbGRcblxuICAgIGNvbnN0IGxpbmVzID0gc291cmNlTWFwLm1hcHBpbmdzLnNwbGl0KCc7Jyk7XG5cbiAgICBmb3IgKGxldCBsaW5lSW5kZXggPSAwOyBsaW5lSW5kZXggPCBsaW5lcy5sZW5ndGg7IGxpbmVJbmRleCsrKSB7XG4gICAgICAvLyByZXNldCBjb2x1bW4gcG9zaXRpb24gdG8gMCBhZnRlciBlYWNoIGxpbmVcbiAgICAgIGxldCBnZW5lcmF0ZWRDb2RlQ29sdW1uID0gMDtcbiAgICAgIC8vIGRlY29kZSBzZWN0aW9ucyBpbiBsaW5lXG4gICAgICBjb25zdCBjb2x1bW5zID0gbGluZXNbbGluZUluZGV4XS5zcGxpdCgnLCcpO1xuXG4gICAgICBmb3IgKGxldCBjb2x1bW5JbmRleCA9IDA7IGNvbHVtbkluZGV4IDwgY29sdW1ucy5sZW5ndGg7IGNvbHVtbkluZGV4KyspIHtcbiAgICAgICAgY29uc3QgZGVjb2RlZFNlY3Rpb24gPSB2bHEuZGVjb2RlKGNvbHVtbnNbY29sdW1uSW5kZXhdKTtcbiAgICAgICAgaWYgKGRlY29kZWRTZWN0aW9uLmxlbmd0aCA+PSA0KSB7XG4gICAgICAgICAgLy8gdXBkYXRlIHJlbGF0aXZlIHBvc2l0aW9uc1xuICAgICAgICAgIGdlbmVyYXRlZENvZGVDb2x1bW4gKz0gZGVjb2RlZFNlY3Rpb25bMF07XG4gICAgICAgICAgc291cmNlRmlsZUluZGV4ICs9IGRlY29kZWRTZWN0aW9uWzFdO1xuICAgICAgICAgIHNvdXJjZUNvZGVMaW5lICs9IGRlY29kZWRTZWN0aW9uWzJdO1xuICAgICAgICAgIHNvdXJjZUNvZGVDb2x1bW4gKz0gZGVjb2RlZFNlY3Rpb25bM107XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaGVjayBpZiBtYXRjaGluZyBtYXBcbiAgICAgICAgaWYgKGxpbmVJbmRleCA9PT0gcG9zaXRpb24ubGluZU51bWJlcikge1xuICAgICAgICAgIGlmIChnZW5lcmF0ZWRDb2RlQ29sdW1uID09PSBwb3NpdGlvbi5jb2x1bW5OdW1iZXIpIHtcbiAgICAgICAgICAgIC8vIG1hdGNoaW5nIGNvbHVtbiBhbmQgbGluZSBmb3VuZFxuICAgICAgICAgICAgcmV0dXJuIG5ldyBMb2dQb3NpdGlvbihzb3VyY2VNYXAuc291cmNlc1tzb3VyY2VGaWxlSW5kZXhdLCBzb3VyY2VDb2RlTGluZSwgc291cmNlQ29kZUNvbHVtbik7XG4gICAgICAgICAgfSBlbHNlIGlmIChjb2x1bW5JbmRleCArIDEgPT09IGNvbHVtbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBtYXRjaGluZyBjb2x1bW4gbm90IGZvdW5kLCBidXQgbGluZSBpcyBjb3JyZWN0XG4gICAgICAgICAgICByZXR1cm4gbmV3IExvZ1Bvc2l0aW9uKHNvdXJjZU1hcC5zb3VyY2VzW3NvdXJjZUZpbGVJbmRleF0sIHNvdXJjZUNvZGVMaW5lLCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gZmFpbGVkIGlmIHJlYWNoZWRcbiAgICByZXR1cm4gbmV3IExvZ1Bvc2l0aW9uKCd1bmtub3duJywgMCwgMCk7XG4gIH1cblxuICAvKipcbiAgICogZG9lcyB0aGUgaHR0cCBnZXQgcmVxdWVzdCB0byBnZXQgdGhlIHNvdXJjZSBtYXBcbiAgICogQHBhcmFtIHNvdXJjZU1hcExvY2F0aW9uXG4gICAqIEBwYXJhbSBkaXN0UG9zaXRpb25cbiAgICovXG4gIHByaXZhdGUgX2dldFNvdXJjZU1hcChzb3VyY2VNYXBMb2NhdGlvbjogc3RyaW5nLCBkaXN0UG9zaXRpb246IExvZ1Bvc2l0aW9uKTogT2JzZXJ2YWJsZTxMb2dQb3NpdGlvbj4ge1xuICAgIGNvbnN0IHJlcSA9IG5ldyBIdHRwUmVxdWVzdDxTb3VyY2VNYXA+KCdHRVQnLCBzb3VyY2VNYXBMb2NhdGlvbik7XG5cbiAgICByZXR1cm4gdGhpcy5odHRwQmFja2VuZC5oYW5kbGUocmVxKS5waXBlKFxuICAgICAgZmlsdGVyKGUgPT4gKGUgaW5zdGFuY2VvZiBIdHRwUmVzcG9uc2UpKSxcbiAgICAgIG1hcDxIdHRwUmVzcG9uc2U8U291cmNlTWFwPiwgU291cmNlTWFwPigoaHR0cFJlc3BvbnNlOiBIdHRwUmVzcG9uc2U8U291cmNlTWFwPikgPT4gaHR0cFJlc3BvbnNlLmJvZHkpLFxuICAgICAgbWFwPFNvdXJjZU1hcCwgTG9nUG9zaXRpb24+KHNvdXJjZU1hcCA9PiB7XG4gICAgICAgIC8vIHN0b3JlIGZpbGUgaW4gY2FjaGUgaWYgbm90IGFscmVhZHkgc3RvcmVkXG4gICAgICAgIGlmICghdGhpcy5jYWNoZS5oYXNPd25Qcm9wZXJ0eShzb3VyY2VNYXBMb2NhdGlvbikpIHtcbiAgICAgICAgICB0aGlzLmNhY2hlW3NvdXJjZU1hcExvY2F0aW9uXSA9IHNvdXJjZU1hcDtcbiAgICAgICAgfVxuICAgICAgICAvLyBtYXAgZ2VuZXJhdGVkIHBvc2l0aW9uIHRvIHNvdXJjZSBwb3NpdGlvblxuICAgICAgICByZXR1cm4gTkdYTWFwcGVyU2VydmljZS5nZXRNYXBwaW5nKHNvdXJjZU1hcCwgZGlzdFBvc2l0aW9uKTtcbiAgICAgIH0pLFxuICAgICAgcmV0cnkoMyksXG4gICAgICAvLyBpZiB0aGVyZSBpcyBhbiBlcnJvciBnZXR0aW5nIHRoZSBzb3VyY2UsIG1hcCBmYWxsIGJhY2sgdG8gdGhlIGZpbGVuYW1lIGFuZCBsaW5lIG51bWJlciBvZlxuICAgICAgY2F0Y2hFcnJvcigoKSA9PiB7XG4gICAgICAgIHRoaXMuZXJyb3JDYWNoZVtzb3VyY2VNYXBMb2NhdGlvbl0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gb2YoZGlzdFBvc2l0aW9uKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBMb2dQb3NpdGlvbiBmb3IgdGhlIGN1cnJlbnQgbG9nXG4gICAqIElmIHNvdXJjZU1hcHMgYXJlIGVuYWJsZWQsIGl0IGF0dGVtcHMgdG8gZ2V0IHRoZSBzb3VyY2UgbWFwIGZyb20gdGhlIHNlcnZlciwgYW5kIHVzZSB0aGF0IHRvIHBhcnNlIHRoZSBmaWxlIG5hbWVcbiAgICogYW5kIG51bWJlciBvZiB0aGUgY2FsbFxuICAgKiBAcGFyYW0gc291cmNlTWFwc0VuYWJsZWRcbiAgICovXG4gIHB1YmxpYyBnZXRDYWxsZXJEZXRhaWxzKHNvdXJjZU1hcHNFbmFibGVkOiBib29sZWFuKTogT2JzZXJ2YWJsZTxMb2dQb3NpdGlvbj4ge1xuICAgIC8vIHBhcnNlIGdlbmVyYXRlZCBmaWxlIG1hcHBpbmcgZnJvbSBzdGFjayB0cmFjZVxuXG4gICAgY29uc3Qgc3RhY2tMaW5lID0gTkdYTWFwcGVyU2VydmljZS5nZXRTdGFja0xpbmUoKTtcblxuICAgIC8vIGlmIHdlIHdlcmUgbm90IGFibGUgdG8gcGFyc2UgdGhlIHN0YWNrTGluZSwganVzdCByZXR1cm4gYW4gZW1wdHkgTG9nIFBvc2l0aW9uXG4gICAgaWYgKCFzdGFja0xpbmUpIHtcbiAgICAgIHJldHVybiBvZihuZXcgTG9nUG9zaXRpb24oJycsIDAsIDApKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb2YoW1xuICAgICAgTkdYTWFwcGVyU2VydmljZS5nZXRQb3NpdGlvbihzdGFja0xpbmUpLFxuICAgICAgTkdYTWFwcGVyU2VydmljZS5nZXRNYXBGaWxlUGF0aChzdGFja0xpbmUpXG4gICAgXSkucGlwZShcbiAgICAgIHN3aXRjaE1hcDxbTG9nUG9zaXRpb24sIHN0cmluZ10sIE9ic2VydmFibGU8TG9nUG9zaXRpb24+PigoW2Rpc3RQb3NpdGlvbiwgc291cmNlTWFwTG9jYXRpb25dKSA9PiB7XG5cbiAgICAgICAgLy8gaWYgc291cmNlIG1hcHMgYXJlIG5vdCBlbmFibGVkLCBvciBpZiB3ZSd2ZSBwcmV2aW91c2x5IHRyaWVkIHRvIGdldCB0aGUgc291cmNlIG1hcHMsIGJ1dCB0aGV5IGZhaWxlZCxcbiAgICAgICAgLy8gdGhlbiBqdXN0IHVzZSB0aGUgcG9zaXRpb24gb2YgdGhlIEpTIGluc3RlYWQgb2YgdGhlIHNvdXJjZVxuICAgICAgICBpZiAoIXNvdXJjZU1hcHNFbmFibGVkIHx8IHRoaXMuZXJyb3JDYWNoZS5oYXNPd25Qcm9wZXJ0eShzb3VyY2VNYXBMb2NhdGlvbikpIHtcbiAgICAgICAgICByZXR1cm4gb2YoZGlzdFBvc2l0aW9uKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgLy8gY2hlY2sgaWYgd2UgaGF2ZSBtYXAgaGFzIGFscmVhZHksIG90aGVyd2lzZSByZXF1ZXN0IGZyb20gc2VydmVyXG4gICAgICAgIGlmICh0aGlzLmNhY2hlLmhhc093blByb3BlcnR5KHNvdXJjZU1hcExvY2F0aW9uKSkge1xuICAgICAgICAgIHJldHVybiBvZihOR1hNYXBwZXJTZXJ2aWNlLmdldE1hcHBpbmcodGhpcy5jYWNoZVtzb3VyY2VNYXBMb2NhdGlvbl0sIGRpc3RQb3NpdGlvbikpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmluYWxseSB0cnkgdG8gZ2V0IHRoZSBzb3VyY2UgbWFwIGFuZCByZXR1cm4gdGhlIHBvc2l0aW9uXG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRTb3VyY2VNYXAoc291cmNlTWFwTG9jYXRpb24sIGRpc3RQb3NpdGlvbik7XG4gICAgICB9KVxuICAgICk7XG5cblxuICB9XG59XG5cblxuXG5cbiJdfQ==